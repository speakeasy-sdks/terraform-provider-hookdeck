// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"hashicups/internal/sdk/pkg/models/shared"
	"net/http"
	"time"
)

// GetEventsAttempts2 - Filter by number of attempts
type GetEventsAttempts2 struct {
	Any      *bool  `queryParam:"name=any"`
	Contains *int64 `queryParam:"name=contains"`
	Gt       *int64 `queryParam:"name=gt"`
	Gte      *int64 `queryParam:"name=gte"`
	Le       *int64 `queryParam:"name=le"`
	Lte      *int64 `queryParam:"name=lte"`
}

type GetEventsAttemptsType string

const (
	GetEventsAttemptsTypeInteger            GetEventsAttemptsType = "integer"
	GetEventsAttemptsTypeGetEventsAttempts2 GetEventsAttemptsType = "getEventsAttempts_2"
)

type GetEventsAttempts struct {
	Integer            *int64
	GetEventsAttempts2 *GetEventsAttempts2

	Type GetEventsAttemptsType
}

func CreateGetEventsAttemptsInteger(integer int64) GetEventsAttempts {
	typ := GetEventsAttemptsTypeInteger

	return GetEventsAttempts{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateGetEventsAttemptsGetEventsAttempts2(getEventsAttempts2 GetEventsAttempts2) GetEventsAttempts {
	typ := GetEventsAttemptsTypeGetEventsAttempts2

	return GetEventsAttempts{
		GetEventsAttempts2: &getEventsAttempts2,
		Type:               typ,
	}
}

func (u *GetEventsAttempts) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	integer := new(int64)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&integer); err == nil {
		u.Integer = integer
		u.Type = GetEventsAttemptsTypeInteger
		return nil
	}

	getEventsAttempts2 := new(GetEventsAttempts2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getEventsAttempts2); err == nil {
		u.GetEventsAttempts2 = getEventsAttempts2
		u.Type = GetEventsAttemptsTypeGetEventsAttempts2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsAttempts) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return json.Marshal(u.Integer)
	}

	if u.GetEventsAttempts2 != nil {
		return json.Marshal(u.GetEventsAttempts2)
	}

	return nil, nil
}

// GetEventsBody2 - URL Encoded string of the JSON to match to the data body
type GetEventsBody2 struct {
}

type GetEventsBodyType string

const (
	GetEventsBodyTypeStr            GetEventsBodyType = "str"
	GetEventsBodyTypeGetEventsBody2 GetEventsBodyType = "getEventsBody_2"
)

type GetEventsBody struct {
	Str            *string
	GetEventsBody2 *GetEventsBody2

	Type GetEventsBodyType
}

func CreateGetEventsBodyStr(str string) GetEventsBody {
	typ := GetEventsBodyTypeStr

	return GetEventsBody{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetEventsBodyGetEventsBody2(getEventsBody2 GetEventsBody2) GetEventsBody {
	typ := GetEventsBodyTypeGetEventsBody2

	return GetEventsBody{
		GetEventsBody2: &getEventsBody2,
		Type:           typ,
	}
}

func (u *GetEventsBody) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetEventsBodyTypeStr
		return nil
	}

	getEventsBody2 := new(GetEventsBody2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getEventsBody2); err == nil {
		u.GetEventsBody2 = getEventsBody2
		u.Type = GetEventsBodyTypeGetEventsBody2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsBody) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.GetEventsBody2 != nil {
		return json.Marshal(u.GetEventsBody2)
	}

	return nil, nil
}

type GetEventsBulkRetryIDType string

const (
	GetEventsBulkRetryIDTypeStr        GetEventsBulkRetryIDType = "str"
	GetEventsBulkRetryIDTypeArrayOfstr GetEventsBulkRetryIDType = "arrayOfstr"
)

type GetEventsBulkRetryID struct {
	Str        *string
	ArrayOfstr []string

	Type GetEventsBulkRetryIDType
}

func CreateGetEventsBulkRetryIDStr(str string) GetEventsBulkRetryID {
	typ := GetEventsBulkRetryIDTypeStr

	return GetEventsBulkRetryID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetEventsBulkRetryIDArrayOfstr(arrayOfstr []string) GetEventsBulkRetryID {
	typ := GetEventsBulkRetryIDTypeArrayOfstr

	return GetEventsBulkRetryID{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetEventsBulkRetryID) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetEventsBulkRetryIDTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetEventsBulkRetryIDTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsBulkRetryID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

// GetEventsCliID2 - Filter by CLI IDs. `?[any]=true` operator for any CLI.
type GetEventsCliID2 struct {
	Any *bool `queryParam:"name=any"`
}

type GetEventsCliIDType string

const (
	GetEventsCliIDTypeStr             GetEventsCliIDType = "str"
	GetEventsCliIDTypeGetEventsCliID2 GetEventsCliIDType = "getEventsCliID_2"
	GetEventsCliIDTypeArrayOfstr      GetEventsCliIDType = "arrayOfstr"
)

type GetEventsCliID struct {
	Str             *string
	GetEventsCliID2 *GetEventsCliID2
	ArrayOfstr      []string

	Type GetEventsCliIDType
}

func CreateGetEventsCliIDStr(str string) GetEventsCliID {
	typ := GetEventsCliIDTypeStr

	return GetEventsCliID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetEventsCliIDGetEventsCliID2(getEventsCliID2 GetEventsCliID2) GetEventsCliID {
	typ := GetEventsCliIDTypeGetEventsCliID2

	return GetEventsCliID{
		GetEventsCliID2: &getEventsCliID2,
		Type:            typ,
	}
}

func CreateGetEventsCliIDArrayOfstr(arrayOfstr []string) GetEventsCliID {
	typ := GetEventsCliIDTypeArrayOfstr

	return GetEventsCliID{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetEventsCliID) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetEventsCliIDTypeStr
		return nil
	}

	getEventsCliID2 := new(GetEventsCliID2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getEventsCliID2); err == nil {
		u.GetEventsCliID2 = getEventsCliID2
		u.Type = GetEventsCliIDTypeGetEventsCliID2
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetEventsCliIDTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsCliID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.GetEventsCliID2 != nil {
		return json.Marshal(u.GetEventsCliID2)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

type GetEventsCliUserIDType string

const (
	GetEventsCliUserIDTypeStr        GetEventsCliUserIDType = "str"
	GetEventsCliUserIDTypeArrayOfstr GetEventsCliUserIDType = "arrayOfstr"
)

type GetEventsCliUserID struct {
	Str        *string
	ArrayOfstr []string

	Type GetEventsCliUserIDType
}

func CreateGetEventsCliUserIDStr(str string) GetEventsCliUserID {
	typ := GetEventsCliUserIDTypeStr

	return GetEventsCliUserID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetEventsCliUserIDArrayOfstr(arrayOfstr []string) GetEventsCliUserID {
	typ := GetEventsCliUserIDTypeArrayOfstr

	return GetEventsCliUserID{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetEventsCliUserID) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetEventsCliUserIDTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetEventsCliUserIDTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsCliUserID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

// GetEventsCreatedAt2 - Filter by `created_at` date using a date operator
type GetEventsCreatedAt2 struct {
	Any *bool      `queryParam:"name=any"`
	Gt  *time.Time `queryParam:"name=gt"`
	Gte *time.Time `queryParam:"name=gte"`
	Le  *time.Time `queryParam:"name=le"`
	Lte *time.Time `queryParam:"name=lte"`
}

type GetEventsCreatedAtType string

const (
	GetEventsCreatedAtTypeDateTime            GetEventsCreatedAtType = "date-time"
	GetEventsCreatedAtTypeGetEventsCreatedAt2 GetEventsCreatedAtType = "getEventsCreatedAt_2"
)

type GetEventsCreatedAt struct {
	DateTime            *time.Time
	GetEventsCreatedAt2 *GetEventsCreatedAt2

	Type GetEventsCreatedAtType
}

func CreateGetEventsCreatedAtDateTime(dateTime time.Time) GetEventsCreatedAt {
	typ := GetEventsCreatedAtTypeDateTime

	return GetEventsCreatedAt{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateGetEventsCreatedAtGetEventsCreatedAt2(getEventsCreatedAt2 GetEventsCreatedAt2) GetEventsCreatedAt {
	typ := GetEventsCreatedAtTypeGetEventsCreatedAt2

	return GetEventsCreatedAt{
		GetEventsCreatedAt2: &getEventsCreatedAt2,
		Type:                typ,
	}
}

func (u *GetEventsCreatedAt) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	dateTime := new(time.Time)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&dateTime); err == nil {
		u.DateTime = dateTime
		u.Type = GetEventsCreatedAtTypeDateTime
		return nil
	}

	getEventsCreatedAt2 := new(GetEventsCreatedAt2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getEventsCreatedAt2); err == nil {
		u.GetEventsCreatedAt2 = getEventsCreatedAt2
		u.Type = GetEventsCreatedAtTypeGetEventsCreatedAt2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsCreatedAt) MarshalJSON() ([]byte, error) {
	if u.DateTime != nil {
		return json.Marshal(u.DateTime)
	}

	if u.GetEventsCreatedAt2 != nil {
		return json.Marshal(u.GetEventsCreatedAt2)
	}

	return nil, nil
}

type GetEventsDestinationIDType string

const (
	GetEventsDestinationIDTypeStr        GetEventsDestinationIDType = "str"
	GetEventsDestinationIDTypeArrayOfstr GetEventsDestinationIDType = "arrayOfstr"
)

type GetEventsDestinationID struct {
	Str        *string
	ArrayOfstr []string

	Type GetEventsDestinationIDType
}

func CreateGetEventsDestinationIDStr(str string) GetEventsDestinationID {
	typ := GetEventsDestinationIDTypeStr

	return GetEventsDestinationID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetEventsDestinationIDArrayOfstr(arrayOfstr []string) GetEventsDestinationID {
	typ := GetEventsDestinationIDTypeArrayOfstr

	return GetEventsDestinationID{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetEventsDestinationID) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetEventsDestinationIDTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetEventsDestinationIDTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsDestinationID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

type GetEventsDir2 string

const (
	GetEventsDir2Asc  GetEventsDir2 = "asc"
	GetEventsDir2Desc GetEventsDir2 = "desc"
)

func (e GetEventsDir2) ToPointer() *GetEventsDir2 {
	return &e
}

func (e *GetEventsDir2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "asc":
		fallthrough
	case "desc":
		*e = GetEventsDir2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetEventsDir2: %v", v)
	}
}

// GetEventsDir1 - Sort direction
type GetEventsDir1 string

const (
	GetEventsDir1Asc  GetEventsDir1 = "asc"
	GetEventsDir1Desc GetEventsDir1 = "desc"
)

func (e GetEventsDir1) ToPointer() *GetEventsDir1 {
	return &e
}

func (e *GetEventsDir1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "asc":
		fallthrough
	case "desc":
		*e = GetEventsDir1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetEventsDir1: %v", v)
	}
}

type GetEventsDirType string

const (
	GetEventsDirTypeGetEventsDir1        GetEventsDirType = "getEventsDir_1"
	GetEventsDirTypeArrayOfgetEventsDir2 GetEventsDirType = "arrayOfgetEventsDir_2"
)

type GetEventsDir struct {
	GetEventsDir1        *GetEventsDir1
	ArrayOfgetEventsDir2 []GetEventsDir2

	Type GetEventsDirType
}

func CreateGetEventsDirGetEventsDir1(getEventsDir1 GetEventsDir1) GetEventsDir {
	typ := GetEventsDirTypeGetEventsDir1

	return GetEventsDir{
		GetEventsDir1: &getEventsDir1,
		Type:          typ,
	}
}

func CreateGetEventsDirArrayOfgetEventsDir2(arrayOfgetEventsDir2 []GetEventsDir2) GetEventsDir {
	typ := GetEventsDirTypeArrayOfgetEventsDir2

	return GetEventsDir{
		ArrayOfgetEventsDir2: arrayOfgetEventsDir2,
		Type:                 typ,
	}
}

func (u *GetEventsDir) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	getEventsDir1 := new(GetEventsDir1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getEventsDir1); err == nil {
		u.GetEventsDir1 = getEventsDir1
		u.Type = GetEventsDirTypeGetEventsDir1
		return nil
	}

	arrayOfgetEventsDir2 := []GetEventsDir2{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfgetEventsDir2); err == nil {
		u.ArrayOfgetEventsDir2 = arrayOfgetEventsDir2
		u.Type = GetEventsDirTypeArrayOfgetEventsDir2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsDir) MarshalJSON() ([]byte, error) {
	if u.GetEventsDir1 != nil {
		return json.Marshal(u.GetEventsDir1)
	}

	if u.ArrayOfgetEventsDir2 != nil {
		return json.Marshal(u.ArrayOfgetEventsDir2)
	}

	return nil, nil
}

type GetEventsErrorCodeType string

const (
	GetEventsErrorCodeTypeStr        GetEventsErrorCodeType = "str"
	GetEventsErrorCodeTypeArrayOfstr GetEventsErrorCodeType = "arrayOfstr"
)

type GetEventsErrorCode struct {
	Str        *string
	ArrayOfstr []string

	Type GetEventsErrorCodeType
}

func CreateGetEventsErrorCodeStr(str string) GetEventsErrorCode {
	typ := GetEventsErrorCodeTypeStr

	return GetEventsErrorCode{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetEventsErrorCodeArrayOfstr(arrayOfstr []string) GetEventsErrorCode {
	typ := GetEventsErrorCodeTypeArrayOfstr

	return GetEventsErrorCode{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetEventsErrorCode) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetEventsErrorCodeTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetEventsErrorCodeTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsErrorCode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

type GetEventsEventDataIDType string

const (
	GetEventsEventDataIDTypeStr        GetEventsEventDataIDType = "str"
	GetEventsEventDataIDTypeArrayOfstr GetEventsEventDataIDType = "arrayOfstr"
)

type GetEventsEventDataID struct {
	Str        *string
	ArrayOfstr []string

	Type GetEventsEventDataIDType
}

func CreateGetEventsEventDataIDStr(str string) GetEventsEventDataID {
	typ := GetEventsEventDataIDTypeStr

	return GetEventsEventDataID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetEventsEventDataIDArrayOfstr(arrayOfstr []string) GetEventsEventDataID {
	typ := GetEventsEventDataIDTypeArrayOfstr

	return GetEventsEventDataID{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetEventsEventDataID) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetEventsEventDataIDTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetEventsEventDataIDTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsEventDataID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

// GetEventsHeaders2 - URL Encoded string of the JSON to match to the data headers
type GetEventsHeaders2 struct {
}

type GetEventsHeadersType string

const (
	GetEventsHeadersTypeStr               GetEventsHeadersType = "str"
	GetEventsHeadersTypeGetEventsHeaders2 GetEventsHeadersType = "getEventsHeaders_2"
)

type GetEventsHeaders struct {
	Str               *string
	GetEventsHeaders2 *GetEventsHeaders2

	Type GetEventsHeadersType
}

func CreateGetEventsHeadersStr(str string) GetEventsHeaders {
	typ := GetEventsHeadersTypeStr

	return GetEventsHeaders{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetEventsHeadersGetEventsHeaders2(getEventsHeaders2 GetEventsHeaders2) GetEventsHeaders {
	typ := GetEventsHeadersTypeGetEventsHeaders2

	return GetEventsHeaders{
		GetEventsHeaders2: &getEventsHeaders2,
		Type:              typ,
	}
}

func (u *GetEventsHeaders) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetEventsHeadersTypeStr
		return nil
	}

	getEventsHeaders2 := new(GetEventsHeaders2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getEventsHeaders2); err == nil {
		u.GetEventsHeaders2 = getEventsHeaders2
		u.Type = GetEventsHeadersTypeGetEventsHeaders2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsHeaders) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.GetEventsHeaders2 != nil {
		return json.Marshal(u.GetEventsHeaders2)
	}

	return nil, nil
}

type GetEventsIDType string

const (
	GetEventsIDTypeStr        GetEventsIDType = "str"
	GetEventsIDTypeArrayOfstr GetEventsIDType = "arrayOfstr"
)

type GetEventsID struct {
	Str        *string
	ArrayOfstr []string

	Type GetEventsIDType
}

func CreateGetEventsIDStr(str string) GetEventsID {
	typ := GetEventsIDTypeStr

	return GetEventsID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetEventsIDArrayOfstr(arrayOfstr []string) GetEventsID {
	typ := GetEventsIDTypeArrayOfstr

	return GetEventsID{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetEventsID) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetEventsIDTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetEventsIDTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

// GetEventsInclude - Include the data object in the event model
type GetEventsInclude string

const (
	GetEventsIncludeData GetEventsInclude = "data"
)

func (e GetEventsInclude) ToPointer() *GetEventsInclude {
	return &e
}

func (e *GetEventsInclude) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "data":
		*e = GetEventsInclude(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetEventsInclude: %v", v)
	}
}

type GetEventsIssueIDType string

const (
	GetEventsIssueIDTypeStr        GetEventsIssueIDType = "str"
	GetEventsIssueIDTypeArrayOfstr GetEventsIssueIDType = "arrayOfstr"
)

type GetEventsIssueID struct {
	Str        *string
	ArrayOfstr []string

	Type GetEventsIssueIDType
}

func CreateGetEventsIssueIDStr(str string) GetEventsIssueID {
	typ := GetEventsIssueIDTypeStr

	return GetEventsIssueID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetEventsIssueIDArrayOfstr(arrayOfstr []string) GetEventsIssueID {
	typ := GetEventsIssueIDTypeArrayOfstr

	return GetEventsIssueID{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetEventsIssueID) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetEventsIssueIDTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetEventsIssueIDTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsIssueID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

// GetEventsLastAttemptAt2 - Filter by `last_attempt_at` date using a date operator
type GetEventsLastAttemptAt2 struct {
	Any *bool      `queryParam:"name=any"`
	Gt  *time.Time `queryParam:"name=gt"`
	Gte *time.Time `queryParam:"name=gte"`
	Le  *time.Time `queryParam:"name=le"`
	Lte *time.Time `queryParam:"name=lte"`
}

type GetEventsLastAttemptAtType string

const (
	GetEventsLastAttemptAtTypeDateTime                GetEventsLastAttemptAtType = "date-time"
	GetEventsLastAttemptAtTypeGetEventsLastAttemptAt2 GetEventsLastAttemptAtType = "getEventsLastAttemptAt_2"
)

type GetEventsLastAttemptAt struct {
	DateTime                *time.Time
	GetEventsLastAttemptAt2 *GetEventsLastAttemptAt2

	Type GetEventsLastAttemptAtType
}

func CreateGetEventsLastAttemptAtDateTime(dateTime time.Time) GetEventsLastAttemptAt {
	typ := GetEventsLastAttemptAtTypeDateTime

	return GetEventsLastAttemptAt{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateGetEventsLastAttemptAtGetEventsLastAttemptAt2(getEventsLastAttemptAt2 GetEventsLastAttemptAt2) GetEventsLastAttemptAt {
	typ := GetEventsLastAttemptAtTypeGetEventsLastAttemptAt2

	return GetEventsLastAttemptAt{
		GetEventsLastAttemptAt2: &getEventsLastAttemptAt2,
		Type:                    typ,
	}
}

func (u *GetEventsLastAttemptAt) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	dateTime := new(time.Time)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&dateTime); err == nil {
		u.DateTime = dateTime
		u.Type = GetEventsLastAttemptAtTypeDateTime
		return nil
	}

	getEventsLastAttemptAt2 := new(GetEventsLastAttemptAt2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getEventsLastAttemptAt2); err == nil {
		u.GetEventsLastAttemptAt2 = getEventsLastAttemptAt2
		u.Type = GetEventsLastAttemptAtTypeGetEventsLastAttemptAt2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsLastAttemptAt) MarshalJSON() ([]byte, error) {
	if u.DateTime != nil {
		return json.Marshal(u.DateTime)
	}

	if u.GetEventsLastAttemptAt2 != nil {
		return json.Marshal(u.GetEventsLastAttemptAt2)
	}

	return nil, nil
}

type GetEventsOrderBy2 string

const (
	GetEventsOrderBy2LastAttemptAt GetEventsOrderBy2 = "last_attempt_at"
	GetEventsOrderBy2NextAttemptAt GetEventsOrderBy2 = "next_attempt_at"
	GetEventsOrderBy2CreatedAt     GetEventsOrderBy2 = "created_at"
)

func (e GetEventsOrderBy2) ToPointer() *GetEventsOrderBy2 {
	return &e
}

func (e *GetEventsOrderBy2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "last_attempt_at":
		fallthrough
	case "next_attempt_at":
		fallthrough
	case "created_at":
		*e = GetEventsOrderBy2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetEventsOrderBy2: %v", v)
	}
}

// GetEventsOrderBy1 - Sort key(s)
type GetEventsOrderBy1 string

const (
	GetEventsOrderBy1LastAttemptAt GetEventsOrderBy1 = "last_attempt_at"
	GetEventsOrderBy1NextAttemptAt GetEventsOrderBy1 = "next_attempt_at"
	GetEventsOrderBy1CreatedAt     GetEventsOrderBy1 = "created_at"
)

func (e GetEventsOrderBy1) ToPointer() *GetEventsOrderBy1 {
	return &e
}

func (e *GetEventsOrderBy1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "last_attempt_at":
		fallthrough
	case "next_attempt_at":
		fallthrough
	case "created_at":
		*e = GetEventsOrderBy1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetEventsOrderBy1: %v", v)
	}
}

type GetEventsOrderByType string

const (
	GetEventsOrderByTypeGetEventsOrderBy1        GetEventsOrderByType = "getEventsOrderBy_1"
	GetEventsOrderByTypeArrayOfgetEventsOrderBy2 GetEventsOrderByType = "arrayOfgetEventsOrderBy_2"
)

type GetEventsOrderBy struct {
	GetEventsOrderBy1        *GetEventsOrderBy1
	ArrayOfgetEventsOrderBy2 []GetEventsOrderBy2

	Type GetEventsOrderByType
}

func CreateGetEventsOrderByGetEventsOrderBy1(getEventsOrderBy1 GetEventsOrderBy1) GetEventsOrderBy {
	typ := GetEventsOrderByTypeGetEventsOrderBy1

	return GetEventsOrderBy{
		GetEventsOrderBy1: &getEventsOrderBy1,
		Type:              typ,
	}
}

func CreateGetEventsOrderByArrayOfgetEventsOrderBy2(arrayOfgetEventsOrderBy2 []GetEventsOrderBy2) GetEventsOrderBy {
	typ := GetEventsOrderByTypeArrayOfgetEventsOrderBy2

	return GetEventsOrderBy{
		ArrayOfgetEventsOrderBy2: arrayOfgetEventsOrderBy2,
		Type:                     typ,
	}
}

func (u *GetEventsOrderBy) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	getEventsOrderBy1 := new(GetEventsOrderBy1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getEventsOrderBy1); err == nil {
		u.GetEventsOrderBy1 = getEventsOrderBy1
		u.Type = GetEventsOrderByTypeGetEventsOrderBy1
		return nil
	}

	arrayOfgetEventsOrderBy2 := []GetEventsOrderBy2{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfgetEventsOrderBy2); err == nil {
		u.ArrayOfgetEventsOrderBy2 = arrayOfgetEventsOrderBy2
		u.Type = GetEventsOrderByTypeArrayOfgetEventsOrderBy2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsOrderBy) MarshalJSON() ([]byte, error) {
	if u.GetEventsOrderBy1 != nil {
		return json.Marshal(u.GetEventsOrderBy1)
	}

	if u.ArrayOfgetEventsOrderBy2 != nil {
		return json.Marshal(u.ArrayOfgetEventsOrderBy2)
	}

	return nil, nil
}

// GetEventsParsedQuery2 - URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
type GetEventsParsedQuery2 struct {
}

type GetEventsParsedQueryType string

const (
	GetEventsParsedQueryTypeStr                   GetEventsParsedQueryType = "str"
	GetEventsParsedQueryTypeGetEventsParsedQuery2 GetEventsParsedQueryType = "getEventsParsedQuery_2"
)

type GetEventsParsedQuery struct {
	Str                   *string
	GetEventsParsedQuery2 *GetEventsParsedQuery2

	Type GetEventsParsedQueryType
}

func CreateGetEventsParsedQueryStr(str string) GetEventsParsedQuery {
	typ := GetEventsParsedQueryTypeStr

	return GetEventsParsedQuery{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetEventsParsedQueryGetEventsParsedQuery2(getEventsParsedQuery2 GetEventsParsedQuery2) GetEventsParsedQuery {
	typ := GetEventsParsedQueryTypeGetEventsParsedQuery2

	return GetEventsParsedQuery{
		GetEventsParsedQuery2: &getEventsParsedQuery2,
		Type:                  typ,
	}
}

func (u *GetEventsParsedQuery) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetEventsParsedQueryTypeStr
		return nil
	}

	getEventsParsedQuery2 := new(GetEventsParsedQuery2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getEventsParsedQuery2); err == nil {
		u.GetEventsParsedQuery2 = getEventsParsedQuery2
		u.Type = GetEventsParsedQueryTypeGetEventsParsedQuery2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsParsedQuery) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.GetEventsParsedQuery2 != nil {
		return json.Marshal(u.GetEventsParsedQuery2)
	}

	return nil, nil
}

// GetEventsResponseStatus2 - Filter by HTTP response status code
type GetEventsResponseStatus2 struct {
	Any      *bool  `queryParam:"name=any"`
	Contains *int64 `queryParam:"name=contains"`
	Gt       *int64 `queryParam:"name=gt"`
	Gte      *int64 `queryParam:"name=gte"`
	Le       *int64 `queryParam:"name=le"`
	Lte      *int64 `queryParam:"name=lte"`
}

type GetEventsResponseStatusType string

const (
	GetEventsResponseStatusTypeInteger                  GetEventsResponseStatusType = "integer"
	GetEventsResponseStatusTypeGetEventsResponseStatus2 GetEventsResponseStatusType = "getEventsResponseStatus_2"
	GetEventsResponseStatusTypeArrayOfinteger           GetEventsResponseStatusType = "arrayOfinteger"
)

type GetEventsResponseStatus struct {
	Integer                  *int64
	GetEventsResponseStatus2 *GetEventsResponseStatus2
	ArrayOfinteger           []int64

	Type GetEventsResponseStatusType
}

func CreateGetEventsResponseStatusInteger(integer int64) GetEventsResponseStatus {
	typ := GetEventsResponseStatusTypeInteger

	return GetEventsResponseStatus{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateGetEventsResponseStatusGetEventsResponseStatus2(getEventsResponseStatus2 GetEventsResponseStatus2) GetEventsResponseStatus {
	typ := GetEventsResponseStatusTypeGetEventsResponseStatus2

	return GetEventsResponseStatus{
		GetEventsResponseStatus2: &getEventsResponseStatus2,
		Type:                     typ,
	}
}

func CreateGetEventsResponseStatusArrayOfinteger(arrayOfinteger []int64) GetEventsResponseStatus {
	typ := GetEventsResponseStatusTypeArrayOfinteger

	return GetEventsResponseStatus{
		ArrayOfinteger: arrayOfinteger,
		Type:           typ,
	}
}

func (u *GetEventsResponseStatus) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	integer := new(int64)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&integer); err == nil {
		u.Integer = integer
		u.Type = GetEventsResponseStatusTypeInteger
		return nil
	}

	getEventsResponseStatus2 := new(GetEventsResponseStatus2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getEventsResponseStatus2); err == nil {
		u.GetEventsResponseStatus2 = getEventsResponseStatus2
		u.Type = GetEventsResponseStatusTypeGetEventsResponseStatus2
		return nil
	}

	arrayOfinteger := []int64{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfinteger); err == nil {
		u.ArrayOfinteger = arrayOfinteger
		u.Type = GetEventsResponseStatusTypeArrayOfinteger
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsResponseStatus) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return json.Marshal(u.Integer)
	}

	if u.GetEventsResponseStatus2 != nil {
		return json.Marshal(u.GetEventsResponseStatus2)
	}

	if u.ArrayOfinteger != nil {
		return json.Marshal(u.ArrayOfinteger)
	}

	return nil, nil
}

type GetEventsSourceIDType string

const (
	GetEventsSourceIDTypeStr        GetEventsSourceIDType = "str"
	GetEventsSourceIDTypeArrayOfstr GetEventsSourceIDType = "arrayOfstr"
)

type GetEventsSourceID struct {
	Str        *string
	ArrayOfstr []string

	Type GetEventsSourceIDType
}

func CreateGetEventsSourceIDStr(str string) GetEventsSourceID {
	typ := GetEventsSourceIDTypeStr

	return GetEventsSourceID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetEventsSourceIDArrayOfstr(arrayOfstr []string) GetEventsSourceID {
	typ := GetEventsSourceIDTypeArrayOfstr

	return GetEventsSourceID{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetEventsSourceID) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetEventsSourceIDTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetEventsSourceIDTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsSourceID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

type GetEventsStatusType string

const (
	GetEventsStatusTypeEventStatus        GetEventsStatusType = "EventStatus"
	GetEventsStatusTypeArrayOfEventStatus GetEventsStatusType = "arrayOfEventStatus"
)

type GetEventsStatus struct {
	EventStatus        *shared.EventStatus
	ArrayOfEventStatus []shared.EventStatus

	Type GetEventsStatusType
}

func CreateGetEventsStatusEventStatus(eventStatus shared.EventStatus) GetEventsStatus {
	typ := GetEventsStatusTypeEventStatus

	return GetEventsStatus{
		EventStatus: &eventStatus,
		Type:        typ,
	}
}

func CreateGetEventsStatusArrayOfEventStatus(arrayOfEventStatus []shared.EventStatus) GetEventsStatus {
	typ := GetEventsStatusTypeArrayOfEventStatus

	return GetEventsStatus{
		ArrayOfEventStatus: arrayOfEventStatus,
		Type:               typ,
	}
}

func (u *GetEventsStatus) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	eventStatus := new(shared.EventStatus)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&eventStatus); err == nil {
		u.EventStatus = eventStatus
		u.Type = GetEventsStatusTypeEventStatus
		return nil
	}

	arrayOfEventStatus := []shared.EventStatus{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfEventStatus); err == nil {
		u.ArrayOfEventStatus = arrayOfEventStatus
		u.Type = GetEventsStatusTypeArrayOfEventStatus
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsStatus) MarshalJSON() ([]byte, error) {
	if u.EventStatus != nil {
		return json.Marshal(u.EventStatus)
	}

	if u.ArrayOfEventStatus != nil {
		return json.Marshal(u.ArrayOfEventStatus)
	}

	return nil, nil
}

// GetEventsSuccessfulAt2 - Filter by `successful_at` date using a date operator
type GetEventsSuccessfulAt2 struct {
	Any *bool      `queryParam:"name=any"`
	Gt  *time.Time `queryParam:"name=gt"`
	Gte *time.Time `queryParam:"name=gte"`
	Le  *time.Time `queryParam:"name=le"`
	Lte *time.Time `queryParam:"name=lte"`
}

type GetEventsSuccessfulAtType string

const (
	GetEventsSuccessfulAtTypeDateTime               GetEventsSuccessfulAtType = "date-time"
	GetEventsSuccessfulAtTypeGetEventsSuccessfulAt2 GetEventsSuccessfulAtType = "getEventsSuccessfulAt_2"
)

type GetEventsSuccessfulAt struct {
	DateTime               *time.Time
	GetEventsSuccessfulAt2 *GetEventsSuccessfulAt2

	Type GetEventsSuccessfulAtType
}

func CreateGetEventsSuccessfulAtDateTime(dateTime time.Time) GetEventsSuccessfulAt {
	typ := GetEventsSuccessfulAtTypeDateTime

	return GetEventsSuccessfulAt{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateGetEventsSuccessfulAtGetEventsSuccessfulAt2(getEventsSuccessfulAt2 GetEventsSuccessfulAt2) GetEventsSuccessfulAt {
	typ := GetEventsSuccessfulAtTypeGetEventsSuccessfulAt2

	return GetEventsSuccessfulAt{
		GetEventsSuccessfulAt2: &getEventsSuccessfulAt2,
		Type:                   typ,
	}
}

func (u *GetEventsSuccessfulAt) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	dateTime := new(time.Time)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&dateTime); err == nil {
		u.DateTime = dateTime
		u.Type = GetEventsSuccessfulAtTypeDateTime
		return nil
	}

	getEventsSuccessfulAt2 := new(GetEventsSuccessfulAt2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getEventsSuccessfulAt2); err == nil {
		u.GetEventsSuccessfulAt2 = getEventsSuccessfulAt2
		u.Type = GetEventsSuccessfulAtTypeGetEventsSuccessfulAt2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsSuccessfulAt) MarshalJSON() ([]byte, error) {
	if u.DateTime != nil {
		return json.Marshal(u.DateTime)
	}

	if u.GetEventsSuccessfulAt2 != nil {
		return json.Marshal(u.GetEventsSuccessfulAt2)
	}

	return nil, nil
}

type GetEventsWebhookIDType string

const (
	GetEventsWebhookIDTypeStr        GetEventsWebhookIDType = "str"
	GetEventsWebhookIDTypeArrayOfstr GetEventsWebhookIDType = "arrayOfstr"
)

type GetEventsWebhookID struct {
	Str        *string
	ArrayOfstr []string

	Type GetEventsWebhookIDType
}

func CreateGetEventsWebhookIDStr(str string) GetEventsWebhookID {
	typ := GetEventsWebhookIDTypeStr

	return GetEventsWebhookID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetEventsWebhookIDArrayOfstr(arrayOfstr []string) GetEventsWebhookID {
	typ := GetEventsWebhookIDTypeArrayOfstr

	return GetEventsWebhookID{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetEventsWebhookID) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetEventsWebhookIDTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetEventsWebhookIDTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetEventsWebhookID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

type GetEventsRequest struct {
	Attempts      *GetEventsAttempts      `queryParam:"style=form,explode=true,name=attempts"`
	Body          *GetEventsBody          `queryParam:"style=form,explode=true,name=body"`
	BulkRetryID   *GetEventsBulkRetryID   `queryParam:"style=form,explode=true,name=bulk_retry_id"`
	CliID         *GetEventsCliID         `queryParam:"style=form,explode=true,name=cli_id"`
	CliUserID     *GetEventsCliUserID     `queryParam:"style=form,explode=true,name=cli_user_id"`
	CreatedAt     *GetEventsCreatedAt     `queryParam:"style=form,explode=true,name=created_at"`
	DestinationID *GetEventsDestinationID `queryParam:"style=form,explode=true,name=destination_id"`
	Dir           *GetEventsDir           `queryParam:"style=form,explode=true,name=dir"`
	ErrorCode     *GetEventsErrorCode     `queryParam:"style=form,explode=true,name=error_code"`
	EventDataID   *GetEventsEventDataID   `queryParam:"style=form,explode=true,name=event_data_id"`
	Headers       *GetEventsHeaders       `queryParam:"style=form,explode=true,name=headers"`
	ID            *GetEventsID            `queryParam:"style=form,explode=true,name=id"`
	// Include the data object in the event model
	Include        *GetEventsInclude        `queryParam:"style=form,explode=true,name=include"`
	IssueID        *GetEventsIssueID        `queryParam:"style=form,explode=true,name=issue_id"`
	LastAttemptAt  *GetEventsLastAttemptAt  `queryParam:"style=form,explode=true,name=last_attempt_at"`
	Limit          *int64                   `queryParam:"style=form,explode=true,name=limit"`
	Next           *string                  `queryParam:"style=form,explode=true,name=next"`
	OrderBy        *GetEventsOrderBy        `queryParam:"style=form,explode=true,name=order_by"`
	ParsedQuery    *GetEventsParsedQuery    `queryParam:"style=form,explode=true,name=parsed_query"`
	Path           *string                  `queryParam:"style=form,explode=true,name=path"`
	Prev           *string                  `queryParam:"style=form,explode=true,name=prev"`
	ResponseStatus *GetEventsResponseStatus `queryParam:"style=form,explode=true,name=response_status"`
	SearchTerm     *string                  `queryParam:"style=form,explode=true,name=search_term"`
	SourceID       *GetEventsSourceID       `queryParam:"style=form,explode=true,name=source_id"`
	Status         *GetEventsStatus         `queryParam:"style=form,explode=true,name=status"`
	SuccessfulAt   *GetEventsSuccessfulAt   `queryParam:"style=form,explode=true,name=successful_at"`
	WebhookID      *GetEventsWebhookID      `queryParam:"style=form,explode=true,name=webhook_id"`
}

type GetEventsResponse struct {
	// Bad Request
	APIErrorResponse *shared.APIErrorResponse
	ContentType      string
	// List of events
	EventPaginatedResult *shared.EventPaginatedResult
	StatusCode           int
	RawResponse          *http.Response
}
