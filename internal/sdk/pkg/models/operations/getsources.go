// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"hashicups/internal/sdk/pkg/models/shared"
	"hashicups/internal/sdk/pkg/utils"
	"net/http"
	"time"
)

// GetSourcesArchivedAt2 - Date the source was archived
type GetSourcesArchivedAt2 struct {
	Any *bool      `queryParam:"name=any"`
	Gt  *time.Time `queryParam:"name=gt"`
	Gte *time.Time `queryParam:"name=gte"`
	Le  *time.Time `queryParam:"name=le"`
	Lte *time.Time `queryParam:"name=lte"`
}

func (g GetSourcesArchivedAt2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetSourcesArchivedAt2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *GetSourcesArchivedAt2) GetAny() *bool {
	if o == nil {
		return nil
	}
	return o.Any
}

func (o *GetSourcesArchivedAt2) GetGt() *time.Time {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *GetSourcesArchivedAt2) GetGte() *time.Time {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *GetSourcesArchivedAt2) GetLe() *time.Time {
	if o == nil {
		return nil
	}
	return o.Le
}

func (o *GetSourcesArchivedAt2) GetLte() *time.Time {
	if o == nil {
		return nil
	}
	return o.Lte
}

type GetSourcesArchivedAtType string

const (
	GetSourcesArchivedAtTypeDateTime              GetSourcesArchivedAtType = "date-time"
	GetSourcesArchivedAtTypeGetSourcesArchivedAt2 GetSourcesArchivedAtType = "getSourcesArchivedAt_2"
)

type GetSourcesArchivedAt struct {
	DateTime              *time.Time
	GetSourcesArchivedAt2 *GetSourcesArchivedAt2

	Type GetSourcesArchivedAtType
}

func CreateGetSourcesArchivedAtDateTime(dateTime time.Time) GetSourcesArchivedAt {
	typ := GetSourcesArchivedAtTypeDateTime

	return GetSourcesArchivedAt{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateGetSourcesArchivedAtGetSourcesArchivedAt2(getSourcesArchivedAt2 GetSourcesArchivedAt2) GetSourcesArchivedAt {
	typ := GetSourcesArchivedAtTypeGetSourcesArchivedAt2

	return GetSourcesArchivedAt{
		GetSourcesArchivedAt2: &getSourcesArchivedAt2,
		Type:                  typ,
	}
}

func (u *GetSourcesArchivedAt) UnmarshalJSON(data []byte) error {

	getSourcesArchivedAt2 := new(GetSourcesArchivedAt2)
	if err := utils.UnmarshalJSON(data, &getSourcesArchivedAt2, "", true, true); err == nil {
		u.GetSourcesArchivedAt2 = getSourcesArchivedAt2
		u.Type = GetSourcesArchivedAtTypeGetSourcesArchivedAt2
		return nil
	}

	dateTime := new(time.Time)
	if err := utils.UnmarshalJSON(data, &dateTime, "", true, true); err == nil {
		u.DateTime = dateTime
		u.Type = GetSourcesArchivedAtTypeDateTime
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetSourcesArchivedAt) MarshalJSON() ([]byte, error) {
	if u.DateTime != nil {
		return utils.MarshalJSON(u.DateTime, "", true)
	}

	if u.GetSourcesArchivedAt2 != nil {
		return utils.MarshalJSON(u.GetSourcesArchivedAt2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type GetSourcesDir2 string

const (
	GetSourcesDir2Asc  GetSourcesDir2 = "asc"
	GetSourcesDir2Desc GetSourcesDir2 = "desc"
)

func (e GetSourcesDir2) ToPointer() *GetSourcesDir2 {
	return &e
}

func (e *GetSourcesDir2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "asc":
		fallthrough
	case "desc":
		*e = GetSourcesDir2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetSourcesDir2: %v", v)
	}
}

// GetSourcesDir1 - Sort direction
type GetSourcesDir1 string

const (
	GetSourcesDir1Asc  GetSourcesDir1 = "asc"
	GetSourcesDir1Desc GetSourcesDir1 = "desc"
)

func (e GetSourcesDir1) ToPointer() *GetSourcesDir1 {
	return &e
}

func (e *GetSourcesDir1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "asc":
		fallthrough
	case "desc":
		*e = GetSourcesDir1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetSourcesDir1: %v", v)
	}
}

type GetSourcesDirType string

const (
	GetSourcesDirTypeGetSourcesDir1        GetSourcesDirType = "getSourcesDir_1"
	GetSourcesDirTypeArrayOfgetSourcesDir2 GetSourcesDirType = "arrayOfgetSourcesDir_2"
)

type GetSourcesDir struct {
	GetSourcesDir1        *GetSourcesDir1
	ArrayOfgetSourcesDir2 []GetSourcesDir2

	Type GetSourcesDirType
}

func CreateGetSourcesDirGetSourcesDir1(getSourcesDir1 GetSourcesDir1) GetSourcesDir {
	typ := GetSourcesDirTypeGetSourcesDir1

	return GetSourcesDir{
		GetSourcesDir1: &getSourcesDir1,
		Type:           typ,
	}
}

func CreateGetSourcesDirArrayOfgetSourcesDir2(arrayOfgetSourcesDir2 []GetSourcesDir2) GetSourcesDir {
	typ := GetSourcesDirTypeArrayOfgetSourcesDir2

	return GetSourcesDir{
		ArrayOfgetSourcesDir2: arrayOfgetSourcesDir2,
		Type:                  typ,
	}
}

func (u *GetSourcesDir) UnmarshalJSON(data []byte) error {

	getSourcesDir1 := new(GetSourcesDir1)
	if err := utils.UnmarshalJSON(data, &getSourcesDir1, "", true, true); err == nil {
		u.GetSourcesDir1 = getSourcesDir1
		u.Type = GetSourcesDirTypeGetSourcesDir1
		return nil
	}

	arrayOfgetSourcesDir2 := []GetSourcesDir2{}
	if err := utils.UnmarshalJSON(data, &arrayOfgetSourcesDir2, "", true, true); err == nil {
		u.ArrayOfgetSourcesDir2 = arrayOfgetSourcesDir2
		u.Type = GetSourcesDirTypeArrayOfgetSourcesDir2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetSourcesDir) MarshalJSON() ([]byte, error) {
	if u.GetSourcesDir1 != nil {
		return utils.MarshalJSON(u.GetSourcesDir1, "", true)
	}

	if u.ArrayOfgetSourcesDir2 != nil {
		return utils.MarshalJSON(u.ArrayOfgetSourcesDir2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type GetSourcesIDType string

const (
	GetSourcesIDTypeStr        GetSourcesIDType = "str"
	GetSourcesIDTypeArrayOfstr GetSourcesIDType = "arrayOfstr"
)

type GetSourcesID struct {
	Str        *string
	ArrayOfstr []string

	Type GetSourcesIDType
}

func CreateGetSourcesIDStr(str string) GetSourcesID {
	typ := GetSourcesIDTypeStr

	return GetSourcesID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetSourcesIDArrayOfstr(arrayOfstr []string) GetSourcesID {
	typ := GetSourcesIDTypeArrayOfstr

	return GetSourcesID{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetSourcesID) UnmarshalJSON(data []byte) error {

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = GetSourcesIDTypeStr
		return nil
	}

	arrayOfstr := []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfstr, "", true, true); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetSourcesIDTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetSourcesID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfstr != nil {
		return utils.MarshalJSON(u.ArrayOfstr, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// GetSourcesIntegrationID2 - Filter by integration IDs
type GetSourcesIntegrationID2 struct {
	Any *bool `queryParam:"name=any"`
}

func (o *GetSourcesIntegrationID2) GetAny() *bool {
	if o == nil {
		return nil
	}
	return o.Any
}

type GetSourcesIntegrationIDType string

const (
	GetSourcesIntegrationIDTypeStr                      GetSourcesIntegrationIDType = "str"
	GetSourcesIntegrationIDTypeGetSourcesIntegrationID2 GetSourcesIntegrationIDType = "getSourcesIntegrationID_2"
)

type GetSourcesIntegrationID struct {
	Str                      *string
	GetSourcesIntegrationID2 *GetSourcesIntegrationID2

	Type GetSourcesIntegrationIDType
}

func CreateGetSourcesIntegrationIDStr(str string) GetSourcesIntegrationID {
	typ := GetSourcesIntegrationIDTypeStr

	return GetSourcesIntegrationID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetSourcesIntegrationIDGetSourcesIntegrationID2(getSourcesIntegrationID2 GetSourcesIntegrationID2) GetSourcesIntegrationID {
	typ := GetSourcesIntegrationIDTypeGetSourcesIntegrationID2

	return GetSourcesIntegrationID{
		GetSourcesIntegrationID2: &getSourcesIntegrationID2,
		Type:                     typ,
	}
}

func (u *GetSourcesIntegrationID) UnmarshalJSON(data []byte) error {

	getSourcesIntegrationID2 := new(GetSourcesIntegrationID2)
	if err := utils.UnmarshalJSON(data, &getSourcesIntegrationID2, "", true, true); err == nil {
		u.GetSourcesIntegrationID2 = getSourcesIntegrationID2
		u.Type = GetSourcesIntegrationIDTypeGetSourcesIntegrationID2
		return nil
	}

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = GetSourcesIntegrationIDTypeStr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetSourcesIntegrationID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.GetSourcesIntegrationID2 != nil {
		return utils.MarshalJSON(u.GetSourcesIntegrationID2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// GetSourcesName2 - The source name
type GetSourcesName2 struct {
	Any      *bool   `queryParam:"name=any"`
	Contains *string `queryParam:"name=contains"`
	Gt       *string `queryParam:"name=gt"`
	Gte      *string `queryParam:"name=gte"`
	Le       *string `queryParam:"name=le"`
	Lte      *string `queryParam:"name=lte"`
}

func (o *GetSourcesName2) GetAny() *bool {
	if o == nil {
		return nil
	}
	return o.Any
}

func (o *GetSourcesName2) GetContains() *string {
	if o == nil {
		return nil
	}
	return o.Contains
}

func (o *GetSourcesName2) GetGt() *string {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *GetSourcesName2) GetGte() *string {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *GetSourcesName2) GetLe() *string {
	if o == nil {
		return nil
	}
	return o.Le
}

func (o *GetSourcesName2) GetLte() *string {
	if o == nil {
		return nil
	}
	return o.Lte
}

type GetSourcesNameType string

const (
	GetSourcesNameTypeStr             GetSourcesNameType = "str"
	GetSourcesNameTypeGetSourcesName2 GetSourcesNameType = "getSourcesName_2"
)

type GetSourcesName struct {
	Str             *string
	GetSourcesName2 *GetSourcesName2

	Type GetSourcesNameType
}

func CreateGetSourcesNameStr(str string) GetSourcesName {
	typ := GetSourcesNameTypeStr

	return GetSourcesName{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetSourcesNameGetSourcesName2(getSourcesName2 GetSourcesName2) GetSourcesName {
	typ := GetSourcesNameTypeGetSourcesName2

	return GetSourcesName{
		GetSourcesName2: &getSourcesName2,
		Type:            typ,
	}
}

func (u *GetSourcesName) UnmarshalJSON(data []byte) error {

	getSourcesName2 := new(GetSourcesName2)
	if err := utils.UnmarshalJSON(data, &getSourcesName2, "", true, true); err == nil {
		u.GetSourcesName2 = getSourcesName2
		u.Type = GetSourcesNameTypeGetSourcesName2
		return nil
	}

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = GetSourcesNameTypeStr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetSourcesName) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.GetSourcesName2 != nil {
		return utils.MarshalJSON(u.GetSourcesName2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type GetSourcesOrderBy2 string

const (
	GetSourcesOrderBy2CreatedAt GetSourcesOrderBy2 = "created_at"
)

func (e GetSourcesOrderBy2) ToPointer() *GetSourcesOrderBy2 {
	return &e
}

func (e *GetSourcesOrderBy2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "created_at":
		*e = GetSourcesOrderBy2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetSourcesOrderBy2: %v", v)
	}
}

// GetSourcesOrderBy1 - Sort key(s)
type GetSourcesOrderBy1 string

const (
	GetSourcesOrderBy1CreatedAt GetSourcesOrderBy1 = "created_at"
)

func (e GetSourcesOrderBy1) ToPointer() *GetSourcesOrderBy1 {
	return &e
}

func (e *GetSourcesOrderBy1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "created_at":
		*e = GetSourcesOrderBy1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetSourcesOrderBy1: %v", v)
	}
}

type GetSourcesOrderByType string

const (
	GetSourcesOrderByTypeGetSourcesOrderBy1        GetSourcesOrderByType = "getSourcesOrderBy_1"
	GetSourcesOrderByTypeArrayOfgetSourcesOrderBy2 GetSourcesOrderByType = "arrayOfgetSourcesOrderBy_2"
)

type GetSourcesOrderBy struct {
	GetSourcesOrderBy1        *GetSourcesOrderBy1
	ArrayOfgetSourcesOrderBy2 []GetSourcesOrderBy2

	Type GetSourcesOrderByType
}

func CreateGetSourcesOrderByGetSourcesOrderBy1(getSourcesOrderBy1 GetSourcesOrderBy1) GetSourcesOrderBy {
	typ := GetSourcesOrderByTypeGetSourcesOrderBy1

	return GetSourcesOrderBy{
		GetSourcesOrderBy1: &getSourcesOrderBy1,
		Type:               typ,
	}
}

func CreateGetSourcesOrderByArrayOfgetSourcesOrderBy2(arrayOfgetSourcesOrderBy2 []GetSourcesOrderBy2) GetSourcesOrderBy {
	typ := GetSourcesOrderByTypeArrayOfgetSourcesOrderBy2

	return GetSourcesOrderBy{
		ArrayOfgetSourcesOrderBy2: arrayOfgetSourcesOrderBy2,
		Type:                      typ,
	}
}

func (u *GetSourcesOrderBy) UnmarshalJSON(data []byte) error {

	getSourcesOrderBy1 := new(GetSourcesOrderBy1)
	if err := utils.UnmarshalJSON(data, &getSourcesOrderBy1, "", true, true); err == nil {
		u.GetSourcesOrderBy1 = getSourcesOrderBy1
		u.Type = GetSourcesOrderByTypeGetSourcesOrderBy1
		return nil
	}

	arrayOfgetSourcesOrderBy2 := []GetSourcesOrderBy2{}
	if err := utils.UnmarshalJSON(data, &arrayOfgetSourcesOrderBy2, "", true, true); err == nil {
		u.ArrayOfgetSourcesOrderBy2 = arrayOfgetSourcesOrderBy2
		u.Type = GetSourcesOrderByTypeArrayOfgetSourcesOrderBy2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetSourcesOrderBy) MarshalJSON() ([]byte, error) {
	if u.GetSourcesOrderBy1 != nil {
		return utils.MarshalJSON(u.GetSourcesOrderBy1, "", true)
	}

	if u.ArrayOfgetSourcesOrderBy2 != nil {
		return utils.MarshalJSON(u.ArrayOfgetSourcesOrderBy2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type GetSourcesRequest struct {
	Archived      *bool                    `queryParam:"style=form,explode=true,name=archived"`
	ArchivedAt    *GetSourcesArchivedAt    `queryParam:"style=form,explode=true,name=archived_at"`
	Dir           *GetSourcesDir           `queryParam:"style=form,explode=true,name=dir"`
	ID            *GetSourcesID            `queryParam:"style=form,explode=true,name=id"`
	IntegrationID *GetSourcesIntegrationID `queryParam:"style=form,explode=true,name=integration_id"`
	Limit         *int64                   `queryParam:"style=form,explode=true,name=limit"`
	Name          *GetSourcesName          `queryParam:"style=form,explode=true,name=name"`
	Next          *string                  `queryParam:"style=form,explode=true,name=next"`
	OrderBy       *GetSourcesOrderBy       `queryParam:"style=form,explode=true,name=order_by"`
	Prev          *string                  `queryParam:"style=form,explode=true,name=prev"`
}

func (o *GetSourcesRequest) GetArchived() *bool {
	if o == nil {
		return nil
	}
	return o.Archived
}

func (o *GetSourcesRequest) GetArchivedAt() *GetSourcesArchivedAt {
	if o == nil {
		return nil
	}
	return o.ArchivedAt
}

func (o *GetSourcesRequest) GetDir() *GetSourcesDir {
	if o == nil {
		return nil
	}
	return o.Dir
}

func (o *GetSourcesRequest) GetID() *GetSourcesID {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *GetSourcesRequest) GetIntegrationID() *GetSourcesIntegrationID {
	if o == nil {
		return nil
	}
	return o.IntegrationID
}

func (o *GetSourcesRequest) GetLimit() *int64 {
	if o == nil {
		return nil
	}
	return o.Limit
}

func (o *GetSourcesRequest) GetName() *GetSourcesName {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *GetSourcesRequest) GetNext() *string {
	if o == nil {
		return nil
	}
	return o.Next
}

func (o *GetSourcesRequest) GetOrderBy() *GetSourcesOrderBy {
	if o == nil {
		return nil
	}
	return o.OrderBy
}

func (o *GetSourcesRequest) GetPrev() *string {
	if o == nil {
		return nil
	}
	return o.Prev
}

type GetSourcesResponse struct {
	// Bad Request
	APIErrorResponse *shared.APIErrorResponse
	// HTTP response content type for this operation
	ContentType string
	// List of sources
	SourcePaginatedResult *shared.SourcePaginatedResult
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
}

func (o *GetSourcesResponse) GetAPIErrorResponse() *shared.APIErrorResponse {
	if o == nil {
		return nil
	}
	return o.APIErrorResponse
}

func (o *GetSourcesResponse) GetContentType() string {
	if o == nil {
		return ""
	}
	return o.ContentType
}

func (o *GetSourcesResponse) GetSourcePaginatedResult() *shared.SourcePaginatedResult {
	if o == nil {
		return nil
	}
	return o.SourcePaginatedResult
}

func (o *GetSourcesResponse) GetStatusCode() int {
	if o == nil {
		return 0
	}
	return o.StatusCode
}

func (o *GetSourcesResponse) GetRawResponse() *http.Response {
	if o == nil {
		return nil
	}
	return o.RawResponse
}
