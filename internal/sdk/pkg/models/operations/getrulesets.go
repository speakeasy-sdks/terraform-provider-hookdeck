// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"hashicups/internal/sdk/pkg/models/shared"
	"net/http"
	"time"
)

// GetRulesetsArchivedAt2 - Date the ruleset was archived
type GetRulesetsArchivedAt2 struct {
	Any *bool      `queryParam:"name=any"`
	Gt  *time.Time `queryParam:"name=gt"`
	Gte *time.Time `queryParam:"name=gte"`
	Le  *time.Time `queryParam:"name=le"`
	Lte *time.Time `queryParam:"name=lte"`
}

type GetRulesetsArchivedAtType string

const (
	GetRulesetsArchivedAtTypeDateTime               GetRulesetsArchivedAtType = "date-time"
	GetRulesetsArchivedAtTypeGetRulesetsArchivedAt2 GetRulesetsArchivedAtType = "getRulesetsArchivedAt_2"
)

type GetRulesetsArchivedAt struct {
	DateTime               *time.Time
	GetRulesetsArchivedAt2 *GetRulesetsArchivedAt2

	Type GetRulesetsArchivedAtType
}

func CreateGetRulesetsArchivedAtDateTime(dateTime time.Time) GetRulesetsArchivedAt {
	typ := GetRulesetsArchivedAtTypeDateTime

	return GetRulesetsArchivedAt{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateGetRulesetsArchivedAtGetRulesetsArchivedAt2(getRulesetsArchivedAt2 GetRulesetsArchivedAt2) GetRulesetsArchivedAt {
	typ := GetRulesetsArchivedAtTypeGetRulesetsArchivedAt2

	return GetRulesetsArchivedAt{
		GetRulesetsArchivedAt2: &getRulesetsArchivedAt2,
		Type:                   typ,
	}
}

func (u *GetRulesetsArchivedAt) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	dateTime := new(time.Time)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&dateTime); err == nil {
		u.DateTime = dateTime
		u.Type = GetRulesetsArchivedAtTypeDateTime
		return nil
	}

	getRulesetsArchivedAt2 := new(GetRulesetsArchivedAt2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getRulesetsArchivedAt2); err == nil {
		u.GetRulesetsArchivedAt2 = getRulesetsArchivedAt2
		u.Type = GetRulesetsArchivedAtTypeGetRulesetsArchivedAt2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetRulesetsArchivedAt) MarshalJSON() ([]byte, error) {
	if u.DateTime != nil {
		return json.Marshal(u.DateTime)
	}

	if u.GetRulesetsArchivedAt2 != nil {
		return json.Marshal(u.GetRulesetsArchivedAt2)
	}

	return nil, nil
}

type GetRulesetsDir2 string

const (
	GetRulesetsDir2Asc  GetRulesetsDir2 = "asc"
	GetRulesetsDir2Desc GetRulesetsDir2 = "desc"
)

func (e GetRulesetsDir2) ToPointer() *GetRulesetsDir2 {
	return &e
}

func (e *GetRulesetsDir2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "asc":
		fallthrough
	case "desc":
		*e = GetRulesetsDir2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetRulesetsDir2: %v", v)
	}
}

// GetRulesetsDir1 - Sort direction
type GetRulesetsDir1 string

const (
	GetRulesetsDir1Asc  GetRulesetsDir1 = "asc"
	GetRulesetsDir1Desc GetRulesetsDir1 = "desc"
)

func (e GetRulesetsDir1) ToPointer() *GetRulesetsDir1 {
	return &e
}

func (e *GetRulesetsDir1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "asc":
		fallthrough
	case "desc":
		*e = GetRulesetsDir1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetRulesetsDir1: %v", v)
	}
}

type GetRulesetsDirType string

const (
	GetRulesetsDirTypeGetRulesetsDir1        GetRulesetsDirType = "getRulesetsDir_1"
	GetRulesetsDirTypeArrayOfgetRulesetsDir2 GetRulesetsDirType = "arrayOfgetRulesetsDir_2"
)

type GetRulesetsDir struct {
	GetRulesetsDir1        *GetRulesetsDir1
	ArrayOfgetRulesetsDir2 []GetRulesetsDir2

	Type GetRulesetsDirType
}

func CreateGetRulesetsDirGetRulesetsDir1(getRulesetsDir1 GetRulesetsDir1) GetRulesetsDir {
	typ := GetRulesetsDirTypeGetRulesetsDir1

	return GetRulesetsDir{
		GetRulesetsDir1: &getRulesetsDir1,
		Type:            typ,
	}
}

func CreateGetRulesetsDirArrayOfgetRulesetsDir2(arrayOfgetRulesetsDir2 []GetRulesetsDir2) GetRulesetsDir {
	typ := GetRulesetsDirTypeArrayOfgetRulesetsDir2

	return GetRulesetsDir{
		ArrayOfgetRulesetsDir2: arrayOfgetRulesetsDir2,
		Type:                   typ,
	}
}

func (u *GetRulesetsDir) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	getRulesetsDir1 := new(GetRulesetsDir1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getRulesetsDir1); err == nil {
		u.GetRulesetsDir1 = getRulesetsDir1
		u.Type = GetRulesetsDirTypeGetRulesetsDir1
		return nil
	}

	arrayOfgetRulesetsDir2 := []GetRulesetsDir2{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfgetRulesetsDir2); err == nil {
		u.ArrayOfgetRulesetsDir2 = arrayOfgetRulesetsDir2
		u.Type = GetRulesetsDirTypeArrayOfgetRulesetsDir2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetRulesetsDir) MarshalJSON() ([]byte, error) {
	if u.GetRulesetsDir1 != nil {
		return json.Marshal(u.GetRulesetsDir1)
	}

	if u.ArrayOfgetRulesetsDir2 != nil {
		return json.Marshal(u.ArrayOfgetRulesetsDir2)
	}

	return nil, nil
}

type GetRulesetsIDType string

const (
	GetRulesetsIDTypeStr        GetRulesetsIDType = "str"
	GetRulesetsIDTypeArrayOfstr GetRulesetsIDType = "arrayOfstr"
)

type GetRulesetsID struct {
	Str        *string
	ArrayOfstr []string

	Type GetRulesetsIDType
}

func CreateGetRulesetsIDStr(str string) GetRulesetsID {
	typ := GetRulesetsIDTypeStr

	return GetRulesetsID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetRulesetsIDArrayOfstr(arrayOfstr []string) GetRulesetsID {
	typ := GetRulesetsIDTypeArrayOfstr

	return GetRulesetsID{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetRulesetsID) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetRulesetsIDTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetRulesetsIDTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetRulesetsID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

type GetRulesetsName2ContainsType string

const (
	GetRulesetsName2ContainsTypeStr        GetRulesetsName2ContainsType = "str"
	GetRulesetsName2ContainsTypeArrayOfstr GetRulesetsName2ContainsType = "arrayOfstr"
)

type GetRulesetsName2Contains struct {
	Str        *string
	ArrayOfstr []string

	Type GetRulesetsName2ContainsType
}

func CreateGetRulesetsName2ContainsStr(str string) GetRulesetsName2Contains {
	typ := GetRulesetsName2ContainsTypeStr

	return GetRulesetsName2Contains{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetRulesetsName2ContainsArrayOfstr(arrayOfstr []string) GetRulesetsName2Contains {
	typ := GetRulesetsName2ContainsTypeArrayOfstr

	return GetRulesetsName2Contains{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetRulesetsName2Contains) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetRulesetsName2ContainsTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetRulesetsName2ContainsTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetRulesetsName2Contains) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

type GetRulesetsName2GtType string

const (
	GetRulesetsName2GtTypeStr        GetRulesetsName2GtType = "str"
	GetRulesetsName2GtTypeArrayOfstr GetRulesetsName2GtType = "arrayOfstr"
)

type GetRulesetsName2Gt struct {
	Str        *string
	ArrayOfstr []string

	Type GetRulesetsName2GtType
}

func CreateGetRulesetsName2GtStr(str string) GetRulesetsName2Gt {
	typ := GetRulesetsName2GtTypeStr

	return GetRulesetsName2Gt{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetRulesetsName2GtArrayOfstr(arrayOfstr []string) GetRulesetsName2Gt {
	typ := GetRulesetsName2GtTypeArrayOfstr

	return GetRulesetsName2Gt{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetRulesetsName2Gt) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetRulesetsName2GtTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetRulesetsName2GtTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetRulesetsName2Gt) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

type GetRulesetsName2GteType string

const (
	GetRulesetsName2GteTypeStr        GetRulesetsName2GteType = "str"
	GetRulesetsName2GteTypeArrayOfstr GetRulesetsName2GteType = "arrayOfstr"
)

type GetRulesetsName2Gte struct {
	Str        *string
	ArrayOfstr []string

	Type GetRulesetsName2GteType
}

func CreateGetRulesetsName2GteStr(str string) GetRulesetsName2Gte {
	typ := GetRulesetsName2GteTypeStr

	return GetRulesetsName2Gte{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetRulesetsName2GteArrayOfstr(arrayOfstr []string) GetRulesetsName2Gte {
	typ := GetRulesetsName2GteTypeArrayOfstr

	return GetRulesetsName2Gte{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetRulesetsName2Gte) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetRulesetsName2GteTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetRulesetsName2GteTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetRulesetsName2Gte) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

type GetRulesetsName2LeType string

const (
	GetRulesetsName2LeTypeStr        GetRulesetsName2LeType = "str"
	GetRulesetsName2LeTypeArrayOfstr GetRulesetsName2LeType = "arrayOfstr"
)

type GetRulesetsName2Le struct {
	Str        *string
	ArrayOfstr []string

	Type GetRulesetsName2LeType
}

func CreateGetRulesetsName2LeStr(str string) GetRulesetsName2Le {
	typ := GetRulesetsName2LeTypeStr

	return GetRulesetsName2Le{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetRulesetsName2LeArrayOfstr(arrayOfstr []string) GetRulesetsName2Le {
	typ := GetRulesetsName2LeTypeArrayOfstr

	return GetRulesetsName2Le{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetRulesetsName2Le) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetRulesetsName2LeTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetRulesetsName2LeTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetRulesetsName2Le) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

type GetRulesetsName2LteType string

const (
	GetRulesetsName2LteTypeStr        GetRulesetsName2LteType = "str"
	GetRulesetsName2LteTypeArrayOfstr GetRulesetsName2LteType = "arrayOfstr"
)

type GetRulesetsName2Lte struct {
	Str        *string
	ArrayOfstr []string

	Type GetRulesetsName2LteType
}

func CreateGetRulesetsName2LteStr(str string) GetRulesetsName2Lte {
	typ := GetRulesetsName2LteTypeStr

	return GetRulesetsName2Lte{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetRulesetsName2LteArrayOfstr(arrayOfstr []string) GetRulesetsName2Lte {
	typ := GetRulesetsName2LteTypeArrayOfstr

	return GetRulesetsName2Lte{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetRulesetsName2Lte) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetRulesetsName2LteTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetRulesetsName2LteTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetRulesetsName2Lte) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

// GetRulesetsName2 - The ruleset name
type GetRulesetsName2 struct {
	Any      *bool                     `queryParam:"name=any"`
	Contains *GetRulesetsName2Contains `queryParam:"name=contains"`
	Gt       *GetRulesetsName2Gt       `queryParam:"name=gt"`
	Gte      *GetRulesetsName2Gte      `queryParam:"name=gte"`
	Le       *GetRulesetsName2Le       `queryParam:"name=le"`
	Lte      *GetRulesetsName2Lte      `queryParam:"name=lte"`
}

type GetRulesetsName1Type string

const (
	GetRulesetsName1TypeStr        GetRulesetsName1Type = "str"
	GetRulesetsName1TypeArrayOfstr GetRulesetsName1Type = "arrayOfstr"
)

type GetRulesetsName1 struct {
	Str        *string
	ArrayOfstr []string

	Type GetRulesetsName1Type
}

func CreateGetRulesetsName1Str(str string) GetRulesetsName1 {
	typ := GetRulesetsName1TypeStr

	return GetRulesetsName1{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetRulesetsName1ArrayOfstr(arrayOfstr []string) GetRulesetsName1 {
	typ := GetRulesetsName1TypeArrayOfstr

	return GetRulesetsName1{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetRulesetsName1) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetRulesetsName1TypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetRulesetsName1TypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetRulesetsName1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

type GetRulesetsNameType string

const (
	GetRulesetsNameTypeGetRulesetsName1 GetRulesetsNameType = "getRulesetsName_1"
	GetRulesetsNameTypeGetRulesetsName2 GetRulesetsNameType = "getRulesetsName_2"
)

type GetRulesetsName struct {
	GetRulesetsName1 *GetRulesetsName1
	GetRulesetsName2 *GetRulesetsName2

	Type GetRulesetsNameType
}

func CreateGetRulesetsNameGetRulesetsName1(getRulesetsName1 GetRulesetsName1) GetRulesetsName {
	typ := GetRulesetsNameTypeGetRulesetsName1

	return GetRulesetsName{
		GetRulesetsName1: &getRulesetsName1,
		Type:             typ,
	}
}

func CreateGetRulesetsNameGetRulesetsName2(getRulesetsName2 GetRulesetsName2) GetRulesetsName {
	typ := GetRulesetsNameTypeGetRulesetsName2

	return GetRulesetsName{
		GetRulesetsName2: &getRulesetsName2,
		Type:             typ,
	}
}

func (u *GetRulesetsName) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	getRulesetsName1 := new(GetRulesetsName1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getRulesetsName1); err == nil {
		u.GetRulesetsName1 = getRulesetsName1
		u.Type = GetRulesetsNameTypeGetRulesetsName1
		return nil
	}

	getRulesetsName2 := new(GetRulesetsName2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getRulesetsName2); err == nil {
		u.GetRulesetsName2 = getRulesetsName2
		u.Type = GetRulesetsNameTypeGetRulesetsName2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetRulesetsName) MarshalJSON() ([]byte, error) {
	if u.GetRulesetsName1 != nil {
		return json.Marshal(u.GetRulesetsName1)
	}

	if u.GetRulesetsName2 != nil {
		return json.Marshal(u.GetRulesetsName2)
	}

	return nil, nil
}

type GetRulesetsOrderBy2 string

const (
	GetRulesetsOrderBy2CreatedAt GetRulesetsOrderBy2 = "created_at"
)

func (e GetRulesetsOrderBy2) ToPointer() *GetRulesetsOrderBy2 {
	return &e
}

func (e *GetRulesetsOrderBy2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "created_at":
		*e = GetRulesetsOrderBy2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetRulesetsOrderBy2: %v", v)
	}
}

// GetRulesetsOrderBy1 - Sort key(s)
type GetRulesetsOrderBy1 string

const (
	GetRulesetsOrderBy1CreatedAt GetRulesetsOrderBy1 = "created_at"
)

func (e GetRulesetsOrderBy1) ToPointer() *GetRulesetsOrderBy1 {
	return &e
}

func (e *GetRulesetsOrderBy1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "created_at":
		*e = GetRulesetsOrderBy1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetRulesetsOrderBy1: %v", v)
	}
}

type GetRulesetsOrderByType string

const (
	GetRulesetsOrderByTypeGetRulesetsOrderBy1        GetRulesetsOrderByType = "getRulesetsOrderBy_1"
	GetRulesetsOrderByTypeArrayOfgetRulesetsOrderBy2 GetRulesetsOrderByType = "arrayOfgetRulesetsOrderBy_2"
)

type GetRulesetsOrderBy struct {
	GetRulesetsOrderBy1        *GetRulesetsOrderBy1
	ArrayOfgetRulesetsOrderBy2 []GetRulesetsOrderBy2

	Type GetRulesetsOrderByType
}

func CreateGetRulesetsOrderByGetRulesetsOrderBy1(getRulesetsOrderBy1 GetRulesetsOrderBy1) GetRulesetsOrderBy {
	typ := GetRulesetsOrderByTypeGetRulesetsOrderBy1

	return GetRulesetsOrderBy{
		GetRulesetsOrderBy1: &getRulesetsOrderBy1,
		Type:                typ,
	}
}

func CreateGetRulesetsOrderByArrayOfgetRulesetsOrderBy2(arrayOfgetRulesetsOrderBy2 []GetRulesetsOrderBy2) GetRulesetsOrderBy {
	typ := GetRulesetsOrderByTypeArrayOfgetRulesetsOrderBy2

	return GetRulesetsOrderBy{
		ArrayOfgetRulesetsOrderBy2: arrayOfgetRulesetsOrderBy2,
		Type:                       typ,
	}
}

func (u *GetRulesetsOrderBy) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	getRulesetsOrderBy1 := new(GetRulesetsOrderBy1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getRulesetsOrderBy1); err == nil {
		u.GetRulesetsOrderBy1 = getRulesetsOrderBy1
		u.Type = GetRulesetsOrderByTypeGetRulesetsOrderBy1
		return nil
	}

	arrayOfgetRulesetsOrderBy2 := []GetRulesetsOrderBy2{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfgetRulesetsOrderBy2); err == nil {
		u.ArrayOfgetRulesetsOrderBy2 = arrayOfgetRulesetsOrderBy2
		u.Type = GetRulesetsOrderByTypeArrayOfgetRulesetsOrderBy2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetRulesetsOrderBy) MarshalJSON() ([]byte, error) {
	if u.GetRulesetsOrderBy1 != nil {
		return json.Marshal(u.GetRulesetsOrderBy1)
	}

	if u.ArrayOfgetRulesetsOrderBy2 != nil {
		return json.Marshal(u.ArrayOfgetRulesetsOrderBy2)
	}

	return nil, nil
}

type GetRulesetsRequest struct {
	Archived   *bool                  `queryParam:"style=form,explode=true,name=archived"`
	ArchivedAt *GetRulesetsArchivedAt `queryParam:"style=form,explode=true,name=archived_at"`
	Dir        *GetRulesetsDir        `queryParam:"style=form,explode=true,name=dir"`
	ID         *GetRulesetsID         `queryParam:"style=form,explode=true,name=id"`
	Limit      *int64                 `queryParam:"style=form,explode=true,name=limit"`
	Name       *GetRulesetsName       `queryParam:"style=form,explode=true,name=name"`
	Next       *string                `queryParam:"style=form,explode=true,name=next"`
	OrderBy    *GetRulesetsOrderBy    `queryParam:"style=form,explode=true,name=order_by"`
	Prev       *string                `queryParam:"style=form,explode=true,name=prev"`
}

type GetRulesetsResponse struct {
	// Bad Request
	APIErrorResponse *shared.APIErrorResponse
	ContentType      string
	// List of rulesets
	RulesetPaginatedResult *shared.RulesetPaginatedResult
	StatusCode             int
	RawResponse            *http.Response
}
