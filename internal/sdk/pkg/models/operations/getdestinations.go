// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"hashicups/internal/sdk/pkg/models/shared"
	"net/http"
	"time"
)

// GetDestinationsArchivedAt2 - Date the destination was archived
type GetDestinationsArchivedAt2 struct {
	Any *bool      `queryParam:"name=any"`
	Gt  *time.Time `queryParam:"name=gt"`
	Gte *time.Time `queryParam:"name=gte"`
	Le  *time.Time `queryParam:"name=le"`
	Lte *time.Time `queryParam:"name=lte"`
}

type GetDestinationsArchivedAtType string

const (
	GetDestinationsArchivedAtTypeDateTime                   GetDestinationsArchivedAtType = "date-time"
	GetDestinationsArchivedAtTypeGetDestinationsArchivedAt2 GetDestinationsArchivedAtType = "getDestinationsArchivedAt_2"
)

type GetDestinationsArchivedAt struct {
	DateTime                   *time.Time
	GetDestinationsArchivedAt2 *GetDestinationsArchivedAt2

	Type GetDestinationsArchivedAtType
}

func CreateGetDestinationsArchivedAtDateTime(dateTime time.Time) GetDestinationsArchivedAt {
	typ := GetDestinationsArchivedAtTypeDateTime

	return GetDestinationsArchivedAt{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateGetDestinationsArchivedAtGetDestinationsArchivedAt2(getDestinationsArchivedAt2 GetDestinationsArchivedAt2) GetDestinationsArchivedAt {
	typ := GetDestinationsArchivedAtTypeGetDestinationsArchivedAt2

	return GetDestinationsArchivedAt{
		GetDestinationsArchivedAt2: &getDestinationsArchivedAt2,
		Type:                       typ,
	}
}

func (u *GetDestinationsArchivedAt) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	dateTime := new(time.Time)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&dateTime); err == nil {
		u.DateTime = dateTime
		u.Type = GetDestinationsArchivedAtTypeDateTime
		return nil
	}

	getDestinationsArchivedAt2 := new(GetDestinationsArchivedAt2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getDestinationsArchivedAt2); err == nil {
		u.GetDestinationsArchivedAt2 = getDestinationsArchivedAt2
		u.Type = GetDestinationsArchivedAtTypeGetDestinationsArchivedAt2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetDestinationsArchivedAt) MarshalJSON() ([]byte, error) {
	if u.DateTime != nil {
		return json.Marshal(u.DateTime)
	}

	if u.GetDestinationsArchivedAt2 != nil {
		return json.Marshal(u.GetDestinationsArchivedAt2)
	}

	return nil, nil
}

// GetDestinationsCliPath2 - Path for the CLI destination
type GetDestinationsCliPath2 struct {
	Any *bool `queryParam:"name=any"`
}

type GetDestinationsCliPathType string

const (
	GetDestinationsCliPathTypeStr                     GetDestinationsCliPathType = "str"
	GetDestinationsCliPathTypeGetDestinationsCliPath2 GetDestinationsCliPathType = "getDestinationsCliPath_2"
	GetDestinationsCliPathTypeArrayOfstr              GetDestinationsCliPathType = "arrayOfstr"
)

type GetDestinationsCliPath struct {
	Str                     *string
	GetDestinationsCliPath2 *GetDestinationsCliPath2
	ArrayOfstr              []string

	Type GetDestinationsCliPathType
}

func CreateGetDestinationsCliPathStr(str string) GetDestinationsCliPath {
	typ := GetDestinationsCliPathTypeStr

	return GetDestinationsCliPath{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDestinationsCliPathGetDestinationsCliPath2(getDestinationsCliPath2 GetDestinationsCliPath2) GetDestinationsCliPath {
	typ := GetDestinationsCliPathTypeGetDestinationsCliPath2

	return GetDestinationsCliPath{
		GetDestinationsCliPath2: &getDestinationsCliPath2,
		Type:                    typ,
	}
}

func CreateGetDestinationsCliPathArrayOfstr(arrayOfstr []string) GetDestinationsCliPath {
	typ := GetDestinationsCliPathTypeArrayOfstr

	return GetDestinationsCliPath{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetDestinationsCliPath) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetDestinationsCliPathTypeStr
		return nil
	}

	getDestinationsCliPath2 := new(GetDestinationsCliPath2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getDestinationsCliPath2); err == nil {
		u.GetDestinationsCliPath2 = getDestinationsCliPath2
		u.Type = GetDestinationsCliPathTypeGetDestinationsCliPath2
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetDestinationsCliPathTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetDestinationsCliPath) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.GetDestinationsCliPath2 != nil {
		return json.Marshal(u.GetDestinationsCliPath2)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

type GetDestinationsDir2 string

const (
	GetDestinationsDir2Asc  GetDestinationsDir2 = "asc"
	GetDestinationsDir2Desc GetDestinationsDir2 = "desc"
)

func (e GetDestinationsDir2) ToPointer() *GetDestinationsDir2 {
	return &e
}

func (e *GetDestinationsDir2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "asc":
		fallthrough
	case "desc":
		*e = GetDestinationsDir2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDestinationsDir2: %v", v)
	}
}

// GetDestinationsDir1 - Sort direction
type GetDestinationsDir1 string

const (
	GetDestinationsDir1Asc  GetDestinationsDir1 = "asc"
	GetDestinationsDir1Desc GetDestinationsDir1 = "desc"
)

func (e GetDestinationsDir1) ToPointer() *GetDestinationsDir1 {
	return &e
}

func (e *GetDestinationsDir1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "asc":
		fallthrough
	case "desc":
		*e = GetDestinationsDir1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDestinationsDir1: %v", v)
	}
}

type GetDestinationsDirType string

const (
	GetDestinationsDirTypeGetDestinationsDir1        GetDestinationsDirType = "getDestinationsDir_1"
	GetDestinationsDirTypeArrayOfgetDestinationsDir2 GetDestinationsDirType = "arrayOfgetDestinationsDir_2"
)

type GetDestinationsDir struct {
	GetDestinationsDir1        *GetDestinationsDir1
	ArrayOfgetDestinationsDir2 []GetDestinationsDir2

	Type GetDestinationsDirType
}

func CreateGetDestinationsDirGetDestinationsDir1(getDestinationsDir1 GetDestinationsDir1) GetDestinationsDir {
	typ := GetDestinationsDirTypeGetDestinationsDir1

	return GetDestinationsDir{
		GetDestinationsDir1: &getDestinationsDir1,
		Type:                typ,
	}
}

func CreateGetDestinationsDirArrayOfgetDestinationsDir2(arrayOfgetDestinationsDir2 []GetDestinationsDir2) GetDestinationsDir {
	typ := GetDestinationsDirTypeArrayOfgetDestinationsDir2

	return GetDestinationsDir{
		ArrayOfgetDestinationsDir2: arrayOfgetDestinationsDir2,
		Type:                       typ,
	}
}

func (u *GetDestinationsDir) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	getDestinationsDir1 := new(GetDestinationsDir1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getDestinationsDir1); err == nil {
		u.GetDestinationsDir1 = getDestinationsDir1
		u.Type = GetDestinationsDirTypeGetDestinationsDir1
		return nil
	}

	arrayOfgetDestinationsDir2 := []GetDestinationsDir2{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfgetDestinationsDir2); err == nil {
		u.ArrayOfgetDestinationsDir2 = arrayOfgetDestinationsDir2
		u.Type = GetDestinationsDirTypeArrayOfgetDestinationsDir2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetDestinationsDir) MarshalJSON() ([]byte, error) {
	if u.GetDestinationsDir1 != nil {
		return json.Marshal(u.GetDestinationsDir1)
	}

	if u.ArrayOfgetDestinationsDir2 != nil {
		return json.Marshal(u.ArrayOfgetDestinationsDir2)
	}

	return nil, nil
}

type GetDestinationsIDType string

const (
	GetDestinationsIDTypeStr        GetDestinationsIDType = "str"
	GetDestinationsIDTypeArrayOfstr GetDestinationsIDType = "arrayOfstr"
)

type GetDestinationsID struct {
	Str        *string
	ArrayOfstr []string

	Type GetDestinationsIDType
}

func CreateGetDestinationsIDStr(str string) GetDestinationsID {
	typ := GetDestinationsIDTypeStr

	return GetDestinationsID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDestinationsIDArrayOfstr(arrayOfstr []string) GetDestinationsID {
	typ := GetDestinationsIDTypeArrayOfstr

	return GetDestinationsID{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetDestinationsID) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetDestinationsIDTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetDestinationsIDTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetDestinationsID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

// GetDestinationsName2 - The destination name
type GetDestinationsName2 struct {
	Any      *bool   `queryParam:"name=any"`
	Contains *string `queryParam:"name=contains"`
	Gt       *string `queryParam:"name=gt"`
	Gte      *string `queryParam:"name=gte"`
	Le       *string `queryParam:"name=le"`
	Lte      *string `queryParam:"name=lte"`
}

type GetDestinationsNameType string

const (
	GetDestinationsNameTypeStr                  GetDestinationsNameType = "str"
	GetDestinationsNameTypeGetDestinationsName2 GetDestinationsNameType = "getDestinationsName_2"
)

type GetDestinationsName struct {
	Str                  *string
	GetDestinationsName2 *GetDestinationsName2

	Type GetDestinationsNameType
}

func CreateGetDestinationsNameStr(str string) GetDestinationsName {
	typ := GetDestinationsNameTypeStr

	return GetDestinationsName{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDestinationsNameGetDestinationsName2(getDestinationsName2 GetDestinationsName2) GetDestinationsName {
	typ := GetDestinationsNameTypeGetDestinationsName2

	return GetDestinationsName{
		GetDestinationsName2: &getDestinationsName2,
		Type:                 typ,
	}
}

func (u *GetDestinationsName) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetDestinationsNameTypeStr
		return nil
	}

	getDestinationsName2 := new(GetDestinationsName2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getDestinationsName2); err == nil {
		u.GetDestinationsName2 = getDestinationsName2
		u.Type = GetDestinationsNameTypeGetDestinationsName2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetDestinationsName) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.GetDestinationsName2 != nil {
		return json.Marshal(u.GetDestinationsName2)
	}

	return nil, nil
}

type GetDestinationsOrderBy2 string

const (
	GetDestinationsOrderBy2CreatedAt GetDestinationsOrderBy2 = "created_at"
)

func (e GetDestinationsOrderBy2) ToPointer() *GetDestinationsOrderBy2 {
	return &e
}

func (e *GetDestinationsOrderBy2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "created_at":
		*e = GetDestinationsOrderBy2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDestinationsOrderBy2: %v", v)
	}
}

// GetDestinationsOrderBy1 - Sort key(s)
type GetDestinationsOrderBy1 string

const (
	GetDestinationsOrderBy1CreatedAt GetDestinationsOrderBy1 = "created_at"
)

func (e GetDestinationsOrderBy1) ToPointer() *GetDestinationsOrderBy1 {
	return &e
}

func (e *GetDestinationsOrderBy1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "created_at":
		*e = GetDestinationsOrderBy1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDestinationsOrderBy1: %v", v)
	}
}

type GetDestinationsOrderByType string

const (
	GetDestinationsOrderByTypeGetDestinationsOrderBy1        GetDestinationsOrderByType = "getDestinationsOrderBy_1"
	GetDestinationsOrderByTypeArrayOfgetDestinationsOrderBy2 GetDestinationsOrderByType = "arrayOfgetDestinationsOrderBy_2"
)

type GetDestinationsOrderBy struct {
	GetDestinationsOrderBy1        *GetDestinationsOrderBy1
	ArrayOfgetDestinationsOrderBy2 []GetDestinationsOrderBy2

	Type GetDestinationsOrderByType
}

func CreateGetDestinationsOrderByGetDestinationsOrderBy1(getDestinationsOrderBy1 GetDestinationsOrderBy1) GetDestinationsOrderBy {
	typ := GetDestinationsOrderByTypeGetDestinationsOrderBy1

	return GetDestinationsOrderBy{
		GetDestinationsOrderBy1: &getDestinationsOrderBy1,
		Type:                    typ,
	}
}

func CreateGetDestinationsOrderByArrayOfgetDestinationsOrderBy2(arrayOfgetDestinationsOrderBy2 []GetDestinationsOrderBy2) GetDestinationsOrderBy {
	typ := GetDestinationsOrderByTypeArrayOfgetDestinationsOrderBy2

	return GetDestinationsOrderBy{
		ArrayOfgetDestinationsOrderBy2: arrayOfgetDestinationsOrderBy2,
		Type:                           typ,
	}
}

func (u *GetDestinationsOrderBy) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	getDestinationsOrderBy1 := new(GetDestinationsOrderBy1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getDestinationsOrderBy1); err == nil {
		u.GetDestinationsOrderBy1 = getDestinationsOrderBy1
		u.Type = GetDestinationsOrderByTypeGetDestinationsOrderBy1
		return nil
	}

	arrayOfgetDestinationsOrderBy2 := []GetDestinationsOrderBy2{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfgetDestinationsOrderBy2); err == nil {
		u.ArrayOfgetDestinationsOrderBy2 = arrayOfgetDestinationsOrderBy2
		u.Type = GetDestinationsOrderByTypeArrayOfgetDestinationsOrderBy2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetDestinationsOrderBy) MarshalJSON() ([]byte, error) {
	if u.GetDestinationsOrderBy1 != nil {
		return json.Marshal(u.GetDestinationsOrderBy1)
	}

	if u.ArrayOfgetDestinationsOrderBy2 != nil {
		return json.Marshal(u.ArrayOfgetDestinationsOrderBy2)
	}

	return nil, nil
}

type GetDestinationsURLType string

const (
	GetDestinationsURLTypeStr        GetDestinationsURLType = "str"
	GetDestinationsURLTypeArrayOfstr GetDestinationsURLType = "arrayOfstr"
)

type GetDestinationsURL struct {
	Str        *string
	ArrayOfstr []string

	Type GetDestinationsURLType
}

func CreateGetDestinationsURLStr(str string) GetDestinationsURL {
	typ := GetDestinationsURLTypeStr

	return GetDestinationsURL{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDestinationsURLArrayOfstr(arrayOfstr []string) GetDestinationsURL {
	typ := GetDestinationsURLTypeArrayOfstr

	return GetDestinationsURL{
		ArrayOfstr: arrayOfstr,
		Type:       typ,
	}
}

func (u *GetDestinationsURL) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = GetDestinationsURLTypeStr
		return nil
	}

	arrayOfstr := []string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfstr); err == nil {
		u.ArrayOfstr = arrayOfstr
		u.Type = GetDestinationsURLTypeArrayOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetDestinationsURL) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.ArrayOfstr != nil {
		return json.Marshal(u.ArrayOfstr)
	}

	return nil, nil
}

type GetDestinationsRequest struct {
	Archived   *bool                      `queryParam:"style=form,explode=true,name=archived"`
	ArchivedAt *GetDestinationsArchivedAt `queryParam:"style=form,explode=true,name=archived_at"`
	CliPath    *GetDestinationsCliPath    `queryParam:"style=form,explode=true,name=cli_path"`
	Dir        *GetDestinationsDir        `queryParam:"style=form,explode=true,name=dir"`
	ID         *GetDestinationsID         `queryParam:"style=form,explode=true,name=id"`
	Limit      *int64                     `queryParam:"style=form,explode=true,name=limit"`
	Name       *GetDestinationsName       `queryParam:"style=form,explode=true,name=name"`
	Next       *string                    `queryParam:"style=form,explode=true,name=next"`
	OrderBy    *GetDestinationsOrderBy    `queryParam:"style=form,explode=true,name=order_by"`
	Prev       *string                    `queryParam:"style=form,explode=true,name=prev"`
	URL        *GetDestinationsURL        `queryParam:"style=form,explode=true,name=url"`
}

type GetDestinationsResponse struct {
	// Bad Request
	APIErrorResponse *shared.APIErrorResponse
	ContentType      string
	// List of destinations
	DestinationPaginatedResult *shared.DestinationPaginatedResult
	StatusCode                 int
	RawResponse                *http.Response
}
