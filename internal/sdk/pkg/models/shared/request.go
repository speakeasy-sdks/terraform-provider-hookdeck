// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"hashicups/internal/sdk/pkg/utils"
	"time"
)

type RequestDataBody2 struct {
}

type RequestDataBodyType string

const (
	RequestDataBodyTypeStr              RequestDataBodyType = "str"
	RequestDataBodyTypeRequestDataBody2 RequestDataBodyType = "Request_data_body_2"
	RequestDataBodyTypeArrayOfany       RequestDataBodyType = "arrayOfany"
)

type RequestDataBody struct {
	Str              *string
	RequestDataBody2 *RequestDataBody2
	ArrayOfany       []interface{}

	Type RequestDataBodyType
}

func CreateRequestDataBodyStr(str string) RequestDataBody {
	typ := RequestDataBodyTypeStr

	return RequestDataBody{
		Str:  &str,
		Type: typ,
	}
}

func CreateRequestDataBodyRequestDataBody2(requestDataBody2 RequestDataBody2) RequestDataBody {
	typ := RequestDataBodyTypeRequestDataBody2

	return RequestDataBody{
		RequestDataBody2: &requestDataBody2,
		Type:             typ,
	}
}

func CreateRequestDataBodyArrayOfany(arrayOfany []interface{}) RequestDataBody {
	typ := RequestDataBodyTypeArrayOfany

	return RequestDataBody{
		ArrayOfany: arrayOfany,
		Type:       typ,
	}
}

func (u *RequestDataBody) UnmarshalJSON(data []byte) error {

	requestDataBody2 := new(RequestDataBody2)
	if err := utils.UnmarshalJSON(data, &requestDataBody2, "", true, true); err == nil {
		u.RequestDataBody2 = requestDataBody2
		u.Type = RequestDataBodyTypeRequestDataBody2
		return nil
	}

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = RequestDataBodyTypeStr
		return nil
	}

	arrayOfany := []interface{}{}
	if err := utils.UnmarshalJSON(data, &arrayOfany, "", true, true); err == nil {
		u.ArrayOfany = arrayOfany
		u.Type = RequestDataBodyTypeArrayOfany
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u RequestDataBody) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.RequestDataBody2 != nil {
		return utils.MarshalJSON(u.RequestDataBody2, "", true)
	}

	if u.ArrayOfany != nil {
		return utils.MarshalJSON(u.ArrayOfany, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type RequestDataHeadersType string

const (
	RequestDataHeadersTypeStr      RequestDataHeadersType = "str"
	RequestDataHeadersTypeMapOfstr RequestDataHeadersType = "mapOfstr"
)

type RequestDataHeaders struct {
	Str      *string
	MapOfstr map[string]string

	Type RequestDataHeadersType
}

func CreateRequestDataHeadersStr(str string) RequestDataHeaders {
	typ := RequestDataHeadersTypeStr

	return RequestDataHeaders{
		Str:  &str,
		Type: typ,
	}
}

func CreateRequestDataHeadersMapOfstr(mapOfstr map[string]string) RequestDataHeaders {
	typ := RequestDataHeadersTypeMapOfstr

	return RequestDataHeaders{
		MapOfstr: mapOfstr,
		Type:     typ,
	}
}

func (u *RequestDataHeaders) UnmarshalJSON(data []byte) error {

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = RequestDataHeadersTypeStr
		return nil
	}

	mapOfstr := map[string]string{}
	if err := utils.UnmarshalJSON(data, &mapOfstr, "", true, true); err == nil {
		u.MapOfstr = mapOfstr
		u.Type = RequestDataHeadersTypeMapOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u RequestDataHeaders) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.MapOfstr != nil {
		return utils.MarshalJSON(u.MapOfstr, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type RequestDataParsedQuery2 struct {
}

type RequestDataParsedQueryType string

const (
	RequestDataParsedQueryTypeStr                     RequestDataParsedQueryType = "str"
	RequestDataParsedQueryTypeRequestDataParsedQuery2 RequestDataParsedQueryType = "Request_data_parsed_query_2"
)

type RequestDataParsedQuery struct {
	Str                     *string
	RequestDataParsedQuery2 *RequestDataParsedQuery2

	Type RequestDataParsedQueryType
}

func CreateRequestDataParsedQueryStr(str string) RequestDataParsedQuery {
	typ := RequestDataParsedQueryTypeStr

	return RequestDataParsedQuery{
		Str:  &str,
		Type: typ,
	}
}

func CreateRequestDataParsedQueryRequestDataParsedQuery2(requestDataParsedQuery2 RequestDataParsedQuery2) RequestDataParsedQuery {
	typ := RequestDataParsedQueryTypeRequestDataParsedQuery2

	return RequestDataParsedQuery{
		RequestDataParsedQuery2: &requestDataParsedQuery2,
		Type:                    typ,
	}
}

func (u *RequestDataParsedQuery) UnmarshalJSON(data []byte) error {

	requestDataParsedQuery2 := new(RequestDataParsedQuery2)
	if err := utils.UnmarshalJSON(data, &requestDataParsedQuery2, "", true, true); err == nil {
		u.RequestDataParsedQuery2 = requestDataParsedQuery2
		u.Type = RequestDataParsedQueryTypeRequestDataParsedQuery2
		return nil
	}

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = RequestDataParsedQueryTypeStr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u RequestDataParsedQuery) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.RequestDataParsedQuery2 != nil {
		return utils.MarshalJSON(u.RequestDataParsedQuery2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type RequestData struct {
	Body           *RequestDataBody        `json:"body,omitempty"`
	Headers        *RequestDataHeaders     `json:"headers,omitempty"`
	IsLargePayload *bool                   `json:"is_large_payload,omitempty"`
	ParsedQuery    *RequestDataParsedQuery `json:"parsed_query,omitempty"`
	Path           string                  `json:"path"`
	Query          *string                 `json:"query,omitempty"`
}

func (o *RequestData) GetBody() *RequestDataBody {
	if o == nil {
		return nil
	}
	return o.Body
}

func (o *RequestData) GetHeaders() *RequestDataHeaders {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *RequestData) GetIsLargePayload() *bool {
	if o == nil {
		return nil
	}
	return o.IsLargePayload
}

func (o *RequestData) GetParsedQuery() *RequestDataParsedQuery {
	if o == nil {
		return nil
	}
	return o.ParsedQuery
}

func (o *RequestData) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *RequestData) GetQuery() *string {
	if o == nil {
		return nil
	}
	return o.Query
}

// RequestIngestPriority - The priority attributed to the request when received
type RequestIngestPriority string

const (
	RequestIngestPriorityLessThanNilGreaterThan RequestIngestPriority = "<nil>"
	RequestIngestPriorityNormal                 RequestIngestPriority = "NORMAL"
	RequestIngestPriorityLow                    RequestIngestPriority = "LOW"
)

func (e RequestIngestPriority) ToPointer() *RequestIngestPriority {
	return &e
}

func (e *RequestIngestPriority) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "<nil>":
		fallthrough
	case "NORMAL":
		fallthrough
	case "LOW":
		*e = RequestIngestPriority(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RequestIngestPriority: %v", v)
	}
}

type Request struct {
	// The count of CLI events created from this request
	CliEventsCount *int64 `json:"cli_events_count,omitempty"`
	// 	Date the event was created
	CreatedAt time.Time    `json:"created_at"`
	Data      *RequestData `json:"data,omitempty"`
	// Hash of the request data payload used to check for duplicates
	DuplicateHash *string `json:"duplicate_hash,omitempty"`
	// Count of duplicate hits found
	DuplicateHits *int64 `json:"duplicate_hits,omitempty"`
	// The count of events created from this request (CLI events not included)
	EventsCount *int64 `json:"events_count,omitempty"`
	// ID of the request
	ID           string `json:"id"`
	IgnoredCount *int64 `json:"ignored_count,omitempty"`
	// The priority attributed to the request when received
	IngestPriority *RequestIngestPriority `json:"ingest_priority,omitempty"`
	// The time the request was originally received
	IngestedAt   *time.Time `json:"ingested_at,omitempty"`
	IngestedAtID *string    `json:"ingested_at_id,omitempty"`
	// ID of the request data
	OriginalEventDataID *string                `json:"original_event_data_id,omitempty"`
	RejectionCause      *RequestRejectionCause `json:"rejection_cause,omitempty"`
	// ID of the associated source
	SourceID string `json:"source_id"`
	// ID of the workspace
	TeamID string `json:"team_id"`
	// Date the event was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Whether or not the request was verified when received
	Verified *bool `json:"verified,omitempty"`
}

func (r Request) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *Request) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *Request) GetCliEventsCount() *int64 {
	if o == nil {
		return nil
	}
	return o.CliEventsCount
}

func (o *Request) GetCreatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.CreatedAt
}

func (o *Request) GetData() *RequestData {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *Request) GetDuplicateHash() *string {
	if o == nil {
		return nil
	}
	return o.DuplicateHash
}

func (o *Request) GetDuplicateHits() *int64 {
	if o == nil {
		return nil
	}
	return o.DuplicateHits
}

func (o *Request) GetEventsCount() *int64 {
	if o == nil {
		return nil
	}
	return o.EventsCount
}

func (o *Request) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *Request) GetIgnoredCount() *int64 {
	if o == nil {
		return nil
	}
	return o.IgnoredCount
}

func (o *Request) GetIngestPriority() *RequestIngestPriority {
	if o == nil {
		return nil
	}
	return o.IngestPriority
}

func (o *Request) GetIngestedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.IngestedAt
}

func (o *Request) GetIngestedAtID() *string {
	if o == nil {
		return nil
	}
	return o.IngestedAtID
}

func (o *Request) GetOriginalEventDataID() *string {
	if o == nil {
		return nil
	}
	return o.OriginalEventDataID
}

func (o *Request) GetRejectionCause() *RequestRejectionCause {
	if o == nil {
		return nil
	}
	return o.RejectionCause
}

func (o *Request) GetSourceID() string {
	if o == nil {
		return ""
	}
	return o.SourceID
}

func (o *Request) GetTeamID() string {
	if o == nil {
		return ""
	}
	return o.TeamID
}

func (o *Request) GetUpdatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.UpdatedAt
}

func (o *Request) GetVerified() *bool {
	if o == nil {
		return nil
	}
	return o.Verified
}
