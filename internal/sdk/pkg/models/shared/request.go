// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"time"
)

type RequestDataBody2 struct {
}

type RequestDataBodyType string

const (
	RequestDataBodyTypeStr              RequestDataBodyType = "str"
	RequestDataBodyTypeRequestDataBody2 RequestDataBodyType = "Request_data_body_2"
	RequestDataBodyTypeArrayOfany       RequestDataBodyType = "arrayOfany"
)

type RequestDataBody struct {
	Str              *string
	RequestDataBody2 *RequestDataBody2
	ArrayOfany       []interface{}

	Type RequestDataBodyType
}

func CreateRequestDataBodyStr(str string) RequestDataBody {
	typ := RequestDataBodyTypeStr

	return RequestDataBody{
		Str:  &str,
		Type: typ,
	}
}

func CreateRequestDataBodyRequestDataBody2(requestDataBody2 RequestDataBody2) RequestDataBody {
	typ := RequestDataBodyTypeRequestDataBody2

	return RequestDataBody{
		RequestDataBody2: &requestDataBody2,
		Type:             typ,
	}
}

func CreateRequestDataBodyArrayOfany(arrayOfany []interface{}) RequestDataBody {
	typ := RequestDataBodyTypeArrayOfany

	return RequestDataBody{
		ArrayOfany: arrayOfany,
		Type:       typ,
	}
}

func (u *RequestDataBody) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = RequestDataBodyTypeStr
		return nil
	}

	requestDataBody2 := new(RequestDataBody2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&requestDataBody2); err == nil {
		u.RequestDataBody2 = requestDataBody2
		u.Type = RequestDataBodyTypeRequestDataBody2
		return nil
	}

	arrayOfany := []interface{}{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfany); err == nil {
		u.ArrayOfany = arrayOfany
		u.Type = RequestDataBodyTypeArrayOfany
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u RequestDataBody) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.RequestDataBody2 != nil {
		return json.Marshal(u.RequestDataBody2)
	}

	if u.ArrayOfany != nil {
		return json.Marshal(u.ArrayOfany)
	}

	return nil, nil
}

type RequestDataHeadersType string

const (
	RequestDataHeadersTypeStr      RequestDataHeadersType = "str"
	RequestDataHeadersTypeMapOfstr RequestDataHeadersType = "mapOfstr"
)

type RequestDataHeaders struct {
	Str      *string
	MapOfstr map[string]string

	Type RequestDataHeadersType
}

func CreateRequestDataHeadersStr(str string) RequestDataHeaders {
	typ := RequestDataHeadersTypeStr

	return RequestDataHeaders{
		Str:  &str,
		Type: typ,
	}
}

func CreateRequestDataHeadersMapOfstr(mapOfstr map[string]string) RequestDataHeaders {
	typ := RequestDataHeadersTypeMapOfstr

	return RequestDataHeaders{
		MapOfstr: mapOfstr,
		Type:     typ,
	}
}

func (u *RequestDataHeaders) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = RequestDataHeadersTypeStr
		return nil
	}

	mapOfstr := map[string]string{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&mapOfstr); err == nil {
		u.MapOfstr = mapOfstr
		u.Type = RequestDataHeadersTypeMapOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u RequestDataHeaders) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.MapOfstr != nil {
		return json.Marshal(u.MapOfstr)
	}

	return nil, nil
}

type RequestDataParsedQuery2 struct {
}

type RequestDataParsedQueryType string

const (
	RequestDataParsedQueryTypeStr                     RequestDataParsedQueryType = "str"
	RequestDataParsedQueryTypeRequestDataParsedQuery2 RequestDataParsedQueryType = "Request_data_parsed_query_2"
)

type RequestDataParsedQuery struct {
	Str                     *string
	RequestDataParsedQuery2 *RequestDataParsedQuery2

	Type RequestDataParsedQueryType
}

func CreateRequestDataParsedQueryStr(str string) RequestDataParsedQuery {
	typ := RequestDataParsedQueryTypeStr

	return RequestDataParsedQuery{
		Str:  &str,
		Type: typ,
	}
}

func CreateRequestDataParsedQueryRequestDataParsedQuery2(requestDataParsedQuery2 RequestDataParsedQuery2) RequestDataParsedQuery {
	typ := RequestDataParsedQueryTypeRequestDataParsedQuery2

	return RequestDataParsedQuery{
		RequestDataParsedQuery2: &requestDataParsedQuery2,
		Type:                    typ,
	}
}

func (u *RequestDataParsedQuery) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = RequestDataParsedQueryTypeStr
		return nil
	}

	requestDataParsedQuery2 := new(RequestDataParsedQuery2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&requestDataParsedQuery2); err == nil {
		u.RequestDataParsedQuery2 = requestDataParsedQuery2
		u.Type = RequestDataParsedQueryTypeRequestDataParsedQuery2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u RequestDataParsedQuery) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.RequestDataParsedQuery2 != nil {
		return json.Marshal(u.RequestDataParsedQuery2)
	}

	return nil, nil
}

type RequestData struct {
	Body           *RequestDataBody        `json:"body,omitempty"`
	Headers        *RequestDataHeaders     `json:"headers,omitempty"`
	IsLargePayload *bool                   `json:"is_large_payload,omitempty"`
	ParsedQuery    *RequestDataParsedQuery `json:"parsed_query,omitempty"`
	Path           string                  `json:"path"`
	Query          *string                 `json:"query,omitempty"`
}

// RequestIngestPriority - The priority attributed to the request when received
type RequestIngestPriority string

const (
	RequestIngestPriorityLessThanNilGreaterThan RequestIngestPriority = "<nil>"
	RequestIngestPriorityNormal                 RequestIngestPriority = "NORMAL"
	RequestIngestPriorityLow                    RequestIngestPriority = "LOW"
)

func (e RequestIngestPriority) ToPointer() *RequestIngestPriority {
	return &e
}

func (e *RequestIngestPriority) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "<nil>":
		fallthrough
	case "NORMAL":
		fallthrough
	case "LOW":
		*e = RequestIngestPriority(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RequestIngestPriority: %v", v)
	}
}

// Request - A single request
type Request struct {
	// The count of CLI events created from this request
	CliEventsCount *int64 `json:"cli_events_count,omitempty"`
	// 	Date the event was created
	CreatedAt time.Time    `json:"created_at"`
	Data      *RequestData `json:"data,omitempty"`
	// Hash of the request data payload used to check for duplicates
	DuplicateHash *string `json:"duplicate_hash,omitempty"`
	// Count of duplicate hits found
	DuplicateHits *int64 `json:"duplicate_hits,omitempty"`
	// The count of events created from this request (CLI events not included)
	EventsCount *int64 `json:"events_count,omitempty"`
	// ID of the request
	ID           string `json:"id"`
	IgnoredCount *int64 `json:"ignored_count,omitempty"`
	// The priority attributed to the request when received
	IngestPriority *RequestIngestPriority `json:"ingest_priority,omitempty"`
	// The time the request was originally received
	IngestedAt   *time.Time `json:"ingested_at,omitempty"`
	IngestedAtID *string    `json:"ingested_at_id,omitempty"`
	// ID of the request data
	OriginalEventDataID *string                `json:"original_event_data_id,omitempty"`
	RejectionCause      *RequestRejectionCause `json:"rejection_cause,omitempty"`
	// ID of the associated source
	SourceID string `json:"source_id"`
	// ID of the workspace
	TeamID string `json:"team_id"`
	// Date the event was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Whether or not the request was verified when received
	Verified *bool `json:"verified,omitempty"`
}
