// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"time"
)

type BatchOperationQueryType string

const (
	BatchOperationQueryTypeMapOfany BatchOperationQueryType = "mapOfany"
	BatchOperationQueryTypeStr      BatchOperationQueryType = "str"
)

type BatchOperationQuery struct {
	MapOfany map[string]interface{}
	Str      *string

	Type BatchOperationQueryType
}

func CreateBatchOperationQueryMapOfany(mapOfany map[string]interface{}) BatchOperationQuery {
	typ := BatchOperationQueryTypeMapOfany

	return BatchOperationQuery{
		MapOfany: mapOfany,
		Type:     typ,
	}
}

func CreateBatchOperationQueryStr(str string) BatchOperationQuery {
	typ := BatchOperationQueryTypeStr

	return BatchOperationQuery{
		Str:  &str,
		Type: typ,
	}
}

func (u *BatchOperationQuery) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	mapOfany := map[string]interface{}{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&mapOfany); err == nil {
		u.MapOfany = mapOfany
		u.Type = BatchOperationQueryTypeMapOfany
		return nil
	}

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = BatchOperationQueryTypeStr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u BatchOperationQuery) MarshalJSON() ([]byte, error) {
	if u.MapOfany != nil {
		return json.Marshal(u.MapOfany)
	}

	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	return nil, nil
}

// BatchOperation - A single events bulk retry
type BatchOperation struct {
	// Date the bulk retry was cancelled
	CancelledAt *time.Time `json:"cancelled_at,omitempty"`
	// Date the bulk retry was completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`
	// Number of events that were successfully delivered
	CompletedCount *int64 `json:"completed_count,omitempty"`
	// Date the bulk retry was created
	CreatedAt time.Time `json:"created_at"`
	// Number of batches required to complete the bulk retry
	EstimatedBatch *int64 `json:"estimated_batch,omitempty"`
	// Number of estimated events to be retried
	EstimatedCount *int64 `json:"estimated_count,omitempty"`
	// Number of events that failed to be delivered
	FailedCount *int64 `json:"failed_count,omitempty"`
	// ID of the bulk retry
	ID string `json:"id"`
	// Indicates if the bulk retry is currently in progress
	InProgress bool     `json:"in_progress"`
	Number     *float32 `json:"number,omitempty"`
	// Number of batches currently processed
	ProcessedBatch *int64 `json:"processed_batch,omitempty"`
	// Progression of the batch operations, values 0 - 1
	Progress *float32 `json:"progress,omitempty"`
	// Query object to filter records
	Query *BatchOperationQuery `json:"query,omitempty"`
	// ID of the workspace
	TeamID string `json:"team_id"`
	// Last time the bulk retry was updated
	UpdatedAt time.Time `json:"updated_at"`
}
