// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type OrderByDirection4 string

const (
	OrderByDirection4Desc OrderByDirection4 = "DESC"
)

func (e OrderByDirection4) ToPointer() *OrderByDirection4 {
	return &e
}

func (e *OrderByDirection4) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DESC":
		*e = OrderByDirection4(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderByDirection4: %v", v)
	}
}

type OrderByDirection3 string

const (
	OrderByDirection3Asc OrderByDirection3 = "ASC"
)

func (e OrderByDirection3) ToPointer() *OrderByDirection3 {
	return &e
}

func (e *OrderByDirection3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ASC":
		*e = OrderByDirection3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderByDirection3: %v", v)
	}
}

type OrderByDirection2 string

const (
	OrderByDirection2Desc OrderByDirection2 = "desc"
)

func (e OrderByDirection2) ToPointer() *OrderByDirection2 {
	return &e
}

func (e *OrderByDirection2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "desc":
		*e = OrderByDirection2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderByDirection2: %v", v)
	}
}

type OrderByDirection1 string

const (
	OrderByDirection1Asc OrderByDirection1 = "asc"
)

func (e OrderByDirection1) ToPointer() *OrderByDirection1 {
	return &e
}

func (e *OrderByDirection1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "asc":
		*e = OrderByDirection1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderByDirection1: %v", v)
	}
}

type OrderByDirectionType string

const (
	OrderByDirectionTypeOrderByDirection1 OrderByDirectionType = "OrderByDirection_1"
	OrderByDirectionTypeOrderByDirection2 OrderByDirectionType = "OrderByDirection_2"
	OrderByDirectionTypeOrderByDirection3 OrderByDirectionType = "OrderByDirection_3"
	OrderByDirectionTypeOrderByDirection4 OrderByDirectionType = "OrderByDirection_4"
)

type OrderByDirection struct {
	OrderByDirection1 *OrderByDirection1
	OrderByDirection2 *OrderByDirection2
	OrderByDirection3 *OrderByDirection3
	OrderByDirection4 *OrderByDirection4

	Type OrderByDirectionType
}

func CreateOrderByDirectionOrderByDirection1(orderByDirection1 OrderByDirection1) OrderByDirection {
	typ := OrderByDirectionTypeOrderByDirection1

	return OrderByDirection{
		OrderByDirection1: &orderByDirection1,
		Type:              typ,
	}
}

func CreateOrderByDirectionOrderByDirection2(orderByDirection2 OrderByDirection2) OrderByDirection {
	typ := OrderByDirectionTypeOrderByDirection2

	return OrderByDirection{
		OrderByDirection2: &orderByDirection2,
		Type:              typ,
	}
}

func CreateOrderByDirectionOrderByDirection3(orderByDirection3 OrderByDirection3) OrderByDirection {
	typ := OrderByDirectionTypeOrderByDirection3

	return OrderByDirection{
		OrderByDirection3: &orderByDirection3,
		Type:              typ,
	}
}

func CreateOrderByDirectionOrderByDirection4(orderByDirection4 OrderByDirection4) OrderByDirection {
	typ := OrderByDirectionTypeOrderByDirection4

	return OrderByDirection{
		OrderByDirection4: &orderByDirection4,
		Type:              typ,
	}
}

func (u *OrderByDirection) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	orderByDirection1 := new(OrderByDirection1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&orderByDirection1); err == nil {
		u.OrderByDirection1 = orderByDirection1
		u.Type = OrderByDirectionTypeOrderByDirection1
		return nil
	}

	orderByDirection2 := new(OrderByDirection2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&orderByDirection2); err == nil {
		u.OrderByDirection2 = orderByDirection2
		u.Type = OrderByDirectionTypeOrderByDirection2
		return nil
	}

	orderByDirection3 := new(OrderByDirection3)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&orderByDirection3); err == nil {
		u.OrderByDirection3 = orderByDirection3
		u.Type = OrderByDirectionTypeOrderByDirection3
		return nil
	}

	orderByDirection4 := new(OrderByDirection4)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&orderByDirection4); err == nil {
		u.OrderByDirection4 = orderByDirection4
		u.Type = OrderByDirectionTypeOrderByDirection4
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u OrderByDirection) MarshalJSON() ([]byte, error) {
	if u.OrderByDirection1 != nil {
		return json.Marshal(u.OrderByDirection1)
	}

	if u.OrderByDirection2 != nil {
		return json.Marshal(u.OrderByDirection2)
	}

	if u.OrderByDirection3 != nil {
		return json.Marshal(u.OrderByDirection3)
	}

	if u.OrderByDirection4 != nil {
		return json.Marshal(u.OrderByDirection4)
	}

	return nil, nil
}
