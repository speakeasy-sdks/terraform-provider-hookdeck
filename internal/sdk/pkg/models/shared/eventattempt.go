// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"time"
)

// EventAttemptBody1 - Response body from the destination
type EventAttemptBody1 struct {
}

type EventAttemptBodyType string

const (
	EventAttemptBodyTypeEventAttemptBody1 EventAttemptBodyType = "EventAttempt_body_1"
	EventAttemptBodyTypeStr               EventAttemptBodyType = "str"
)

type EventAttemptBody struct {
	EventAttemptBody1 *EventAttemptBody1
	Str               *string

	Type EventAttemptBodyType
}

func CreateEventAttemptBodyEventAttemptBody1(eventAttemptBody1 EventAttemptBody1) EventAttemptBody {
	typ := EventAttemptBodyTypeEventAttemptBody1

	return EventAttemptBody{
		EventAttemptBody1: &eventAttemptBody1,
		Type:              typ,
	}
}

func CreateEventAttemptBodyStr(str string) EventAttemptBody {
	typ := EventAttemptBodyTypeStr

	return EventAttemptBody{
		Str:  &str,
		Type: typ,
	}
}

func (u *EventAttemptBody) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	eventAttemptBody1 := new(EventAttemptBody1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&eventAttemptBody1); err == nil {
		u.EventAttemptBody1 = eventAttemptBody1
		u.Type = EventAttemptBodyTypeEventAttemptBody1
		return nil
	}

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = EventAttemptBodyTypeStr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EventAttemptBody) MarshalJSON() ([]byte, error) {
	if u.EventAttemptBody1 != nil {
		return json.Marshal(u.EventAttemptBody1)
	}

	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	return nil, nil
}

// EventAttemptHTTPMethod - HTTP method used to deliver the attempt
type EventAttemptHTTPMethod string

const (
	EventAttemptHTTPMethodLessThanNilGreaterThan EventAttemptHTTPMethod = "<nil>"
	EventAttemptHTTPMethodGet                    EventAttemptHTTPMethod = "GET"
	EventAttemptHTTPMethodPost                   EventAttemptHTTPMethod = "POST"
	EventAttemptHTTPMethodPut                    EventAttemptHTTPMethod = "PUT"
	EventAttemptHTTPMethodPatch                  EventAttemptHTTPMethod = "PATCH"
	EventAttemptHTTPMethodDelete                 EventAttemptHTTPMethod = "DELETE"
)

func (e EventAttemptHTTPMethod) ToPointer() *EventAttemptHTTPMethod {
	return &e
}

func (e *EventAttemptHTTPMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "<nil>":
		fallthrough
	case "GET":
		fallthrough
	case "POST":
		fallthrough
	case "PUT":
		fallthrough
	case "PATCH":
		fallthrough
	case "DELETE":
		*e = EventAttemptHTTPMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EventAttemptHTTPMethod: %v", v)
	}
}

// EventAttempt - A single attempt
type EventAttempt struct {
	// Date the attempt was archived
	ArchivedAt *string `json:"archived_at,omitempty"`
	// Sequential number of attempts (up to and including this one) made for the associated event
	AttemptNumber *int64            `json:"attempt_number,omitempty"`
	Body          *EventAttemptBody `json:"body,omitempty"`
	// ID of associated bulk retry
	BulkRetryID *string `json:"bulk_retry_id,omitempty"`
	// Date the attempt was created
	CreatedAt time.Time `json:"created_at"`
	// Date the attempt was delivered
	DeliveredAt *time.Time `json:"delivered_at,omitempty"`
	// Time elapsed between attempt initiation and final delivery (in ms)
	DeliveryLatency *int64  `json:"delivery_latency,omitempty"`
	DestinationID   *string `json:"destination_id,omitempty"`
	// Attempt could not complete because of an error
	ErrorCode *AttemptErrorCode `json:"error_code,omitempty"`
	// Event ID
	EventID string `json:"event_id"`
	// HTTP method used to deliver the attempt
	HTTPMethod *EventAttemptHTTPMethod `json:"http_method,omitempty"`
	// Attempt ID
	ID string `json:"id"`
	// URL of the destination where delivery was attempted
	RequestedURL *string `json:"requested_url,omitempty"`
	// Date the destination responded to this attempt
	RespondedAt *time.Time `json:"responded_at,omitempty"`
	// Time elapsed between attempt initiation and a response from the destination (in ms)
	ResponseLatency *int64 `json:"response_latency,omitempty"`
	// Attempt's HTTP response code
	ResponseStatus *int64        `json:"response_status,omitempty"`
	State          *AttemptState `json:"state,omitempty"`
	// Attempt status
	Status AttemptStatus `json:"status"`
	// Date the attempt was successful
	SuccessfulAt *time.Time `json:"successful_at,omitempty"`
	// Team ID
	TeamID string `json:"team_id"`
	// How the attempt was triggered
	Trigger *AttemptTrigger `json:"trigger,omitempty"`
	// Date the attempt was last updated
	UpdatedAt time.Time `json:"updated_at"`
}
